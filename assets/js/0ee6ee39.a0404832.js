(self.webpackChunk=self.webpackChunk||[]).push([[1338],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=c(n),h=i,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||o;return n?a.createElement(m,s(s({ref:t},p),{},{components:n})):a.createElement(m,s({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5778:function(e,t,n){"use strict";n.d(t,{s:function(){return i}});var a=n(7294),i=function(e){var t=e.children,n=e.title,i=void 0===n?"Detailed Explanation":n;return a.createElement("details",{className:"detailed-explanation"},a.createElement("summary",null,a.createElement("h4",null,i)),t)}},1717:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},metadata:function(){return r},toc:function(){return l},default:function(){return p}});var a=n(2122),i=n(9756),o=(n(7294),n(3905)),s=(n(5778),{id:"part-6-performance-normalization",title:"Redux \u5faa\u5e8f\u6e10\u8fdb\uff0c\u7b2c\u516d\u8282\uff1a\u6027\u80fd\u4e0e\u6570\u636e\u8303\u5f0f\u5316",sidebar_label:"\u6027\u80fd\u4e0e\u6570\u636e\u8303\u5f0f\u5316",hide_title:!1,description:"The official Redux Essentials tutorial: learn how to improve app performance and structure data correctly"}),r={unversionedId:"tutorials/essentials/part-6-performance-normalization",id:"tutorials/essentials/part-6-performance-normalization",isDocsHomePage:!1,title:"\u7b2c\u516d\u8282\uff1a\u6027\u80fd\u4e0e\u6570\u636e\u8303\u5f0f\u5316",description:"The official Redux Essentials tutorial: learn how to improve app performance and structure data correctly",source:"@site/../docs/tutorials/essentials/part-6-performance-normalization.md",sourceDirName:"tutorials/essentials",slug:"/tutorials/essentials/part-6-performance-normalization",permalink:"/redux-in-chinese/tutorials/essentials/part-6-performance-normalization",version:"current",sidebar_label:"\u6027\u80fd\u4e0e\u6570\u636e\u8303\u5f0f\u5316",frontMatter:{id:"part-6-performance-normalization",title:"Redux \u5faa\u5e8f\u6e10\u8fdb\uff0c\u7b2c\u516d\u8282\uff1a\u6027\u80fd\u4e0e\u6570\u636e\u8303\u5f0f\u5316",sidebar_label:"\u6027\u80fd\u4e0e\u6570\u636e\u8303\u5f0f\u5316",hide_title:!1,description:"The official Redux Essentials tutorial: learn how to improve app performance and structure data correctly"},sidebar:"docs",previous:{title:"\u7b2c\u4e94\u8282\uff1a\u5f02\u6b65\u903b\u8f91\u4e0e\u6570\u636e\u8bf7\u6c42",permalink:"/redux-in-chinese/tutorials/essentials/part-5-async-logic"},next:{title:"Redux Fundamentals, Part 1: Redux Overview",permalink:"/redux-in-chinese/tutorials/fundamentals/part-1-overview"}},l=[{value:"\u7b80\u4ecb",id:"\u7b80\u4ecb",children:[]},{value:"Adding User Pages",id:"adding-user-pages",children:[]},{value:"Adding Notifications",id:"adding-notifications",children:[{value:"Notifications Slice",id:"notifications-slice",children:[]},{value:"Thunk Arguments",id:"thunk-arguments",children:[]},{value:"Adding the Notifications List",id:"adding-the-notifications-list",children:[]},{value:"Showing New Notifications",id:"showing-new-notifications",children:[]}]},{value:"Improving Render Performance",id:"improving-render-performance",children:[{value:"Investigating Render Behavior",id:"investigating-render-behavior",children:[]},{value:"Memoizing Selector Functions",id:"memoizing-selector-functions",children:[]},{value:"Investigating the Posts List",id:"investigating-the-posts-list",children:[]}]},{value:"Normalizing Data",id:"normalizing-data",children:[{value:"Normalized State Structure",id:"normalized-state-structure",children:[]},{value:"Managing Normalized State with <code>createEntityAdapter</code>",id:"managing-normalized-state-with-createentityadapter",children:[]},{value:"Updating the Posts Slice",id:"updating-the-posts-slice",children:[]},{value:"Optimizing the Posts List",id:"optimizing-the-posts-list",children:[]}]},{value:"Converting Other Slices",id:"converting-other-slices",children:[{value:"Converting the Users Slice",id:"converting-the-users-slice",children:[]},{value:"Converting the Notifications Slice",id:"converting-the-notifications-slice",children:[]}]},{value:"\u4f60\u5b66\u5230\u4e86",id:"\u4f60\u5b66\u5230\u4e86",children:[]},{value:"\u4e0b\u4e00\u6b65",id:"\u4e0b\u4e00\u6b65",children:[]}],c={toc:l};function p(e){var t=e.components,s=(0,i.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"\u4f60\u5c06\u5b66\u5230")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("ul",{parentName:"div"},(0,o.kt)("li",{parentName:"ul"},"\u5982\u4f55\u4f7f\u7528 ",(0,o.kt)("inlineCode",{parentName:"li"},"createSelector")," \u521b\u5efa\u8bb0\u5fc6\u5316\u7684 selector \u51fd\u6570"),(0,o.kt)("li",{parentName:"ul"},"\u4f18\u5316\u7ec4\u4ef6\u6e32\u67d3\u6027\u80fd\u7684\u6a21\u5f0f"),(0,o.kt)("li",{parentName:"ul"},"\u5982\u4f55\u4f7f\u7528 ",(0,o.kt)("inlineCode",{parentName:"li"},"createEntityAdapter")," \u6765\u5b58\u50a8\u548c\u66f4\u65b0\u8303\u5f0f\u5316\u6570\u636e")))),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"\u5fc5\u5907\u80fd\u529b")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("ul",{parentName:"div"},(0,o.kt)("li",{parentName:"ul"},"\u5b8c\u6210\u672c\u6559\u7a0b\u7684\u524d\u51e0\u8282")))),(0,o.kt)("h2",{id:"\u7b80\u4ecb"},"\u7b80\u4ecb"),(0,o.kt)("p",null,"In ",(0,o.kt)("a",{parentName:"p",href:"/redux-in-chinese/tutorials/essentials/part-5-async-logic"},"Part 5: Async Logic and Data Fetching"),", we saw how to write async thunks to fetch data from a server API, patterns for handling async request loading state, and use of selector functions for encapsulating lookups of data from the Redux state."),(0,o.kt)("p",null,"In this final section, we'll look at optimized patterns for ensuring good performance in our application, and techniques for automatically handling common updates of data in the store."),(0,o.kt)("p",null,"So far, most of our functionality has been centered around the ",(0,o.kt)("inlineCode",{parentName:"p"},"posts")," feature. We're going to add a couple new sections of the app. After those are added, we'll look at some specific details of how we've built things, and talk about some weaknesses with what we've built so far and how we can improve the implementation."),(0,o.kt)("h2",{id:"adding-user-pages"},"Adding User Pages"),(0,o.kt)("p",null,"We're fetching a list of users from our fake API, and we can choose a user as the author when we add a new post. But, a social media app needs the ability to look at the page for a specific user and see all the posts they've made. Let's add a page to show the list of all users, and another to show all posts by a specific user."),(0,o.kt)("p",null,"We'll start by adding a new ",(0,o.kt)("inlineCode",{parentName:"p"},"<UsersList>")," component. It follows the usual pattern of reading some data from the store with ",(0,o.kt)("inlineCode",{parentName:"p"},"useSelector"),", and mapping over the array to show a list of users with links to their individual pages:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/users/UsersList.js"',title:'"features/users/UsersList.js"'},"import React from 'react'\nimport { useSelector } from 'react-redux'\nimport { Link } from 'react-router-dom'\nimport { selectAllUsers } from './usersSlice'\n\nexport const UsersList = () => {\n  const users = useSelector(selectAllUsers)\n\n  const renderedUsers = users.map(user => (\n    <li key={user.id}>\n      <Link to={`/users/${user.id}`}>{user.name}</Link>\n    </li>\n  ))\n\n  return (\n    <section>\n      <h2>Users</h2>\n\n      <ul>{renderedUsers}</ul>\n    </section>\n  )\n}\n")),(0,o.kt)("p",null,"We don't yet have a ",(0,o.kt)("inlineCode",{parentName:"p"},"selectAllUsers")," selector, so we'll need to add that to ",(0,o.kt)("inlineCode",{parentName:"p"},"usersSlice.js")," along with a ",(0,o.kt)("inlineCode",{parentName:"p"},"selectUserById")," selector:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="features/users/usersSlice.js"',title:'"features/users/usersSlice.js"'},"export default usersSlice.reducer\n\n// highlight-start\nexport const selectAllUsers = state => state.users\n\nexport const selectUserById = (state, userId) =>\n  state.users.find(user => user.id === userId)\n// highlight-end\n")),(0,o.kt)("p",null,"And we'll add a ",(0,o.kt)("inlineCode",{parentName:"p"},"<UserPage>"),", which is similar to our ",(0,o.kt)("inlineCode",{parentName:"p"},"<SinglePostPage>")," in taking a ",(0,o.kt)("inlineCode",{parentName:"p"},"userId")," parameter from the router:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/users/UserPage.js"',title:'"features/users/UserPage.js"'},"import React from 'react'\nimport { useSelector } from 'react-redux'\nimport { Link } from 'react-router-dom'\n\nimport { selectUserById } from '../users/usersSlice'\nimport { selectAllPosts } from '../posts/postsSlice'\n\nexport const UserPage = ({ match }) => {\n  const { userId } = match.params\n\n  const user = useSelector(state => selectUserById(state, userId))\n\n  const postsForUser = useSelector(state => {\n    const allPosts = selectAllPosts(state)\n    return allPosts.filter(post => post.user === userId)\n  })\n\n  const postTitles = postsForUser.map(post => (\n    <li key={post.id}>\n      <Link to={`/posts/${post.id}`}>{post.title}</Link>\n    </li>\n  ))\n\n  return (\n    <section>\n      <h2>{user.name}</h2>\n\n      <ul>{postTitles}</ul>\n    </section>\n  )\n}\n")),(0,o.kt)("p",null,"As we've seen before, we can take data from one ",(0,o.kt)("inlineCode",{parentName:"p"},"useSelector")," call, or from props, and use that to help decide what to read from the store in another ",(0,o.kt)("inlineCode",{parentName:"p"},"useSelector")," call."),(0,o.kt)("p",null,"Add routes for these components in ",(0,o.kt)("inlineCode",{parentName:"p"},"<App>"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="App.js"',title:'"App.js"'},'          <Route exact path="/posts/:postId" component={SinglePostPage} />\n          <Route exact path="/editPost/:postId" component={EditPostForm} />\n          // highlight-start\n          <Route exact path="/users" component={UsersList} />\n          <Route exact path="/users/:userId" component={UserPage} />\n          // highlight-end\n          <Redirect to="/" />\n')),(0,o.kt)("p",null,"And add another tab in ",(0,o.kt)("inlineCode",{parentName:"p"},"<Navbar>")," that links to ",(0,o.kt)("inlineCode",{parentName:"p"},"/users")," so that we can click and go to ",(0,o.kt)("inlineCode",{parentName:"p"},"<UsersList>"),"."),(0,o.kt)("h2",{id:"adding-notifications"},"Adding Notifications"),(0,o.kt)("p",null,"No social media app would be complete without some notifications popping up to tell us that someone has sent a message, left a comment, or reacted to one of our posts."),(0,o.kt)("p",null,"In a real application, our app client would be in constant communication with the backend server, and the server would push an update to the client every time something happens. Since this is a small example app, we're going to mimic that process by adding a button to actually fetch some notification entries from our fake API. We also don't have any other ",(0,o.kt)("em",{parentName:"p"},"real")," users sending messages or reacting to posts, so the fake API will just create some random notification entries every time we make a request. (Remember, the goal here is to see how to use Redux itself.)"),(0,o.kt)("h3",{id:"notifications-slice"},"Notifications Slice"),(0,o.kt)("p",null,"Since this is a new part of our app, the first step is to create a new slice for our notifications, and an async thunk to fetch some notification entries from the API:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="features/notifications/notificationsSlice.js"',title:'"features/notifications/notificationsSlice.js"'},"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'\n\nimport { client } from '../../api/client'\n\nexport const fetchNotifications = createAsyncThunk(\n  'notifications/fetchNotifications',\n  async (_, { getState }) => {\n    const allNotifications = selectAllNotifications(getState())\n    const [latestNotification] = allNotifications\n    const latestTimestamp = latestNotification ? latestNotification.date : ''\n    const response = await client.get(\n      `/fakeApi/notifications?since=${latestTimestamp}`\n    )\n    return response.notifications\n  }\n)\n\nconst notificationsSlice = createSlice({\n  name: 'notifications',\n  initialState: [],\n  reducers: {},\n  extraReducers: {\n    [fetchNotifications.fulfilled]: (state, action) => {\n      state.push(...action.payload)\n      // Sort with newest first\n      state.sort((a, b) => b.date.localeCompare(a.date))\n    }\n  }\n})\n\nexport default notificationsSlice.reducer\n\nexport const selectAllNotifications = state => state.notifications\n")),(0,o.kt)("p",null,"As with the other slices, import ",(0,o.kt)("inlineCode",{parentName:"p"},"notificationsReducer")," into ",(0,o.kt)("inlineCode",{parentName:"p"},"store.js")," and add it to the ",(0,o.kt)("inlineCode",{parentName:"p"},"configureStore()")," call."),(0,o.kt)("p",null,"We've written an async thunk called ",(0,o.kt)("inlineCode",{parentName:"p"},"fetchNotifications"),", which will retrieve a list of new notifications from the server. As part of that, we want to use the creation timestamp of the most recent notification as part of our request, so that the server knows it should only send back notifications that are actually new."),(0,o.kt)("p",null,"We know that we will be getting back an array of notifications, so we can pass them as separate arguments to ",(0,o.kt)("inlineCode",{parentName:"p"},"state.push()"),", and the array will add each item. We also want to make sure that they're sorted so that the most recent notification is last in the array, just in case the server were to send them out of order. (As a reminder, ",(0,o.kt)("inlineCode",{parentName:"p"},"array.sort()")," always mutates the existing array - this is only safe because we're using ",(0,o.kt)("inlineCode",{parentName:"p"},"createSlice")," and Immer inside.)"),(0,o.kt)("h3",{id:"thunk-arguments"},"Thunk Arguments"),(0,o.kt)("p",null,"If you look at our ",(0,o.kt)("inlineCode",{parentName:"p"},"fetchNotifications")," thunk, it has something new that we haven't seen before. Let's talk about thunk arguments for a minute."),(0,o.kt)("p",null,"We've already seen that we can pass an argument into a thunk action creator when we dispatch it, like ",(0,o.kt)("inlineCode",{parentName:"p"},"dispatch(addPost(newPost))"),". For ",(0,o.kt)("inlineCode",{parentName:"p"},"createAsyncThunk")," specifically, you can only pass in one argument, and whatever we pass in becomes the first argument of the payload creation callback."),(0,o.kt)("p",null,"The second argument to our payload creator is a ",(0,o.kt)("inlineCode",{parentName:"p"},"thunkAPI")," object containing several useful functions and pieces of information:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"dispatch")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"getState"),": the actual ",(0,o.kt)("inlineCode",{parentName:"li"},"dispatch")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"getState")," methods from our Redux store. You can use these inside the thunk to dispatch more actions, or get the latest Redux store state (such as reading an updated value after another action is dispatched)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"extra"),": the \"extra argument\" that can be passed into the thunk middleware when creating the store. This is typically some kind of API wrapper, such as a set of functions that know how to make API calls to your application's server and return data, so that your thunks don't have to have all the URLs and query logic directly inside."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"requestId"),": a unique random ID value for this thunk call. Useful for tracking status of an individual request."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"signal"),": An ",(0,o.kt)("inlineCode",{parentName:"li"},"AbortController.signal")," function that can be used to cancel an in-progress request."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"rejectWithValue"),": a utility that helps customize the contents of a ",(0,o.kt)("inlineCode",{parentName:"li"},"rejected")," action if the thunk receives an error.")),(0,o.kt)("p",null,"(If you're writing a thunk by hand instead of using ",(0,o.kt)("inlineCode",{parentName:"p"},"createAsyncThunk"),", the thunk function will get",(0,o.kt)("inlineCode",{parentName:"p"},"(dispatch, getState)")," as separate arguments, instead of putting them together in one object.)"),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"\u8bf4\u660e")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"For more details on these arguments and how to handle canceling thunks and requests, see ",(0,o.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/createAsyncThunk"},"the ",(0,o.kt)("inlineCode",{parentName:"a"},"createAsyncThunk")," API reference page"),"."))),(0,o.kt)("p",null,"In this case, we know that the list of notifications is in our Redux store state, and that the latest notification should be first in the array. We can destructure the ",(0,o.kt)("inlineCode",{parentName:"p"},"getState")," function out of the ",(0,o.kt)("inlineCode",{parentName:"p"},"thunkAPI")," object, call it to read the state value, and use the ",(0,o.kt)("inlineCode",{parentName:"p"},"selectAllNotifications")," selector to give us just the array of notifications. Since the array of notifications is sorted newest first, we can grab the latest one using array destructuring."),(0,o.kt)("h3",{id:"adding-the-notifications-list"},"Adding the Notifications List"),(0,o.kt)("p",null,"With that slice created, we can add a ",(0,o.kt)("inlineCode",{parentName:"p"},"<NotificationsList>")," component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/notifications/NotificationsList.js"',title:'"features/notifications/NotificationsList.js"'},"import React from 'react'\nimport { useSelector } from 'react-redux'\nimport { formatDistanceToNow, parseISO } from 'date-fns'\n\nimport { selectAllUsers } from '../users/usersSlice'\n\nimport { selectAllNotifications } from './notificationsSlice'\n\nexport const NotificationsList = () => {\n  const notifications = useSelector(selectAllNotifications)\n  const users = useSelector(selectAllUsers)\n\n  const renderedNotifications = notifications.map(notification => {\n    const date = parseISO(notification.date)\n    const timeAgo = formatDistanceToNow(date)\n    const user = users.find(user => user.id === notification.user) || {\n      name: 'Unknown User'\n    }\n\n    return (\n      <div key={notification.id} className=\"notification\">\n        <div>\n          <b>{user.name}</b> {notification.message}\n        </div>\n        <div title={notification.date}>\n          <i>{timeAgo} ago</i>\n        </div>\n      </div>\n    )\n  })\n\n  return (\n    <section className=\"notificationsList\">\n      <h2>Notifications</h2>\n      {renderedNotifications}\n    </section>\n  )\n}\n")),(0,o.kt)("p",null,"Once again, we're reading a list of items from the Redux state, mapping over them, and rendering content for each item."),(0,o.kt)("p",null,"We also need to update the ",(0,o.kt)("inlineCode",{parentName:"p"},"<Navbar>"),' to add a "Notifications" tab, and a new button to fetch some notifications:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="app/Navbar.js"',title:'"app/Navbar.js"'},'import React from \'react\'\n// highlight-next-line\nimport { useDispatch } from \'react-redux\'\nimport { Link } from \'react-router-dom\'\n\n// highlight-next-line\nimport { fetchNotifications } from \'../features/notifications/notificationsSlice\'\n\nexport const Navbar = () => {\n  // highlight-start\n  const dispatch = useDispatch()\n\n  const fetchNewNotifications = () => {\n    dispatch(fetchNotifications())\n  }\n  // highlight-end\n\n  return (\n    <nav>\n      <section>\n        <h1>Redux Essentials Example</h1>\n\n        <div className="navContent">\n          <div className="navLinks">\n            <Link to="/">Posts</Link>\n            <Link to="/users">Users</Link>\n            // highlight-next-line\n            <Link to="/notifications">Notifications</Link>\n          </div>\n          // highlight-start\n          <button className="button" onClick={fetchNewNotifications}>\n            Refresh Notifications\n          </button>\n          // highlight-end\n        </div>\n      </section>\n    </nav>\n  )\n}\n')),(0,o.kt)("p",null,"Lastly, we need to update ",(0,o.kt)("inlineCode",{parentName:"p"},"App.js"),' with the "Notifications" route so we can navigate to it:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="App.js"',title:'"App.js"'},'// omit imports\n// highlight-next-line\nimport { NotificationsList } from \'./features/notifications/NotificationsList\'\n\nfunction App() {\n  return (\n    <Router>\n      <Navbar />\n      <div className="App">\n        <Switch>\n          // highlight-next-line\n          <Route exact path="/notifications" component={NotificationsList} />\n          // omit existing routes\n          <Redirect to="/" />\n        </Switch>\n      </div>\n    </Router>\n  )\n}\n')),(0,o.kt)("p",null,'Here\'s what the "Notifications" tab looks like so far:'),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Initial Notifications tab",src:n(8627).Z})),(0,o.kt)("h3",{id:"showing-new-notifications"},"Showing New Notifications"),(0,o.kt)("p",null,'Each time we click "Refresh Notifications", a few more notification entries will be added to our list. In a real app, those could be coming from the server while we\'re looking at other parts of the UI. We can do something similar by clicking "Refresh Notifications" while we\'re looking at the ',(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"<UserPage>"),'. But, right now we have no idea how many notifications just arrived, and if we keep clicking the button, there could be many notifications we haven\'t read yet. Let\'s add some logic to keep track of which notifications have been read and which of them are "new". That will let us show the count of "Unread" notifications as a badge on our "Notifications" tab in the navbar, and display new notifications in a different color.'),(0,o.kt)("p",null,"Our fake API is already sending back the notification entries with ",(0,o.kt)("inlineCode",{parentName:"p"},"isNew")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"read")," fields, so we can use those in our code."),(0,o.kt)("p",null,"First, we'll update ",(0,o.kt)("inlineCode",{parentName:"p"},"notificationsSlice"),' to have a reducer that marks all notifications as read, and some logic to handle marking existing notifications as "not new":'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="features/notifications/notificationsSlice.js"',title:'"features/notifications/notificationsSlice.js"'},"const notificationsSlice = createSlice({\n  name: 'notifications',\n  initialState: [],\n  reducers: {\n    // highlight-start\n    allNotificationsRead(state, action) {\n      state.forEach(notification => {\n        notification.read = true\n      })\n    }\n    // highlight-end\n  },\n  extraReducers: {\n    [fetchNotifications.fulfilled]: (state, action) => {\n      // highlight-start\n      state.forEach(notification => {\n        // Any notifications we've read are no longer new\n        notification.isNew = !notification.read\n      })\n      // highlight-end\n      state.push(...action.payload)\n      // Sort with newest first\n      state.sort((a, b) => b.date.localeCompare(a.date))\n    }\n  }\n})\n\n// highlight-next-line\nexport const { allNotificationsRead } = notificationsSlice.actions\n\nexport default notificationsSlice.reducer\n")),(0,o.kt)("p",null,"We want to mark these notifications as read whenever our ",(0,o.kt)("inlineCode",{parentName:"p"},"<NotificationsList>")," component renders, either because we clicked on the tab to view the notifications, or because we already have it open and we just received some additional notifications. We can do this by dispatching ",(0,o.kt)("inlineCode",{parentName:"p"},"allNotificationsRead")," in a ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect")," hook. We also want to add an additional classname to any notification list entries in the page, to highlight them:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="features/notifications/NotificationsList.js"',title:'"features/notifications/NotificationsList.js"'},"import React, { useEffect } from 'react'\n// highlight-next-line\nimport { useSelector, useDispatch } from 'react-redux'\nimport { formatDistanceToNow, parseISO } from 'date-fns'\n// highlight-next-line\nimport classnames from 'classnames'\n\nimport { selectAllUsers } from '../users/usersSlice'\n\n// highlight-start\nimport {\n  selectAllNotifications,\n  allNotificationsRead\n} from './notificationsSlice'\n// highlight-end\n\nexport const NotificationsList = () => {\n  // highlight-next-line\n  const dispatch = useDispatch()\n  const notifications = useSelector(selectAllNotifications)\n  const users = useSelector(selectAllUsers)\n\n  // highlight-start\n  useEffect(() => {\n    dispatch(allNotificationsRead())\n  })\n  // highlight-end\n\n  const renderedNotifications = notifications.map(notification => {\n    const date = parseISO(notification.date)\n    const timeAgo = formatDistanceToNow(date)\n    const user = users.find(user => user.id === notification.user) || {\n      name: 'Unknown User'\n    }\n\n    // highlight-start\n    const notificationClassname = classnames('notification', {\n      new: notification.isNew\n    })\n\n    return (\n      <div key={notification.id} className={notificationClassname}>\n        // highlight-end\n        <div>\n          <b>{user.name}</b> {notification.message}\n        </div>\n        <div title={notification.date}>\n          <i>{timeAgo} ago</i>\n        </div>\n      </div>\n    )\n  })\n\n  return (\n    <section className=\"notificationsList\">\n      <h2>Notifications</h2>\n      {renderedNotifications}\n    </section>\n  )\n}\n")),(0,o.kt)("p",null,"This works, but actually has a slightly surprising bit of behavior. Any time there are new notifications (either because we've just switched to this tab, or we've fetched some new notifications from the API), you'll actually see ",(0,o.kt)("em",{parentName:"p"},"two")," ",(0,o.kt)("inlineCode",{parentName:"p"},'"notifications/allNotificationsRead"')," actions dispatched. Why is that?"),(0,o.kt)("p",null,"Let's say we have fetched some notifications while looking at the ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>"),', and then click the "Notifications" tab. The ',(0,o.kt)("inlineCode",{parentName:"p"},"<NotificationsList>")," component will mount, and the ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect")," callback will run after that first render and dispatch ",(0,o.kt)("inlineCode",{parentName:"p"},"allNotificationsRead"),". Our ",(0,o.kt)("inlineCode",{parentName:"p"},"notificationsSlice")," will handle that by updating the notification entries in the store. This creates a new ",(0,o.kt)("inlineCode",{parentName:"p"},"state.notifications")," array containing the immutably-updated entries, which forces our component to render again because it sees a new array returned from the ",(0,o.kt)("inlineCode",{parentName:"p"},"useSelector"),", and the ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect")," hook runs again and dispatches ",(0,o.kt)("inlineCode",{parentName:"p"},"allNotificationsRead")," a second time. The reducer runs again, but this time no data changes, so the component doesn't re-render."),(0,o.kt)("p",null,"There's a couple ways we could potentially avoid that second dispatch, like splitting the logic to dispatch once when the component mounts, and only dispatch again if the size of the notifications array changes. But, this isn't actually hurting anything, so we can leave it alone."),(0,o.kt)("p",null,"This does actually show that ",(0,o.kt)("strong",{parentName:"p"},"it's possible to dispatch an action and not have ",(0,o.kt)("em",{parentName:"strong"},"any")," state changes happen at all"),". Remember, ",(0,o.kt)("strong",{parentName:"p"},"it's always up to your reducers to decide ",(0,o.kt)("em",{parentName:"strong"},"if"),' any state actually needs to be updated, and "nothing needs to happen" is a valid decision for a reducer to make'),"."),(0,o.kt)("p",null,"Here's how the notifications tab looks now that we've got the \"new/read\" behavior working:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"New notifications",src:n(7585).Z})),(0,o.kt)("p",null,'The last thing we need to do before we move on is to add the badge on our "Notifications" tab in the navbar. This will show us the count of "Unread" notifications when we are in other tabs:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="app/Navbar.js"',title:'"app/Navbar.js"'},'// omit imports\n// highlight-next-line\nimport { useDispatch, useSelector } from \'react-redux\'\n\n// highlight-start\nimport {\n  fetchNotifications,\n  selectAllNotifications\n} from \'../features/notifications/notificationsSlice\'\n// highlight-end\n\nexport const Navbar = () => {\n  const dispatch = useDispatch()\n  // highlight-start\n  const notifications = useSelector(selectAllNotifications)\n  const numUnreadNotifications = notifications.filter(n => !n.read).length\n  // highlight-end\n  // omit component contents\n  // highlight-start\n  let unreadNotificationsBadge\n\n  if (numUnreadNotifications > 0) {\n    unreadNotificationsBadge = (\n      <span className="badge">{numUnreadNotifications}</span>\n    )\n  }\n  // highlight-end\n  return (\n    <nav>\n      // omit component contents\n      <div className="navLinks">\n        <Link to="/">Posts</Link>\n        <Link to="/users">Users</Link>\n        // highlight-start\n        <Link to="/notifications">\n          Notifications {unreadNotificationsBadge}\n        </Link>\n        // highlight-end\n      </div>\n      // omit component contents\n    </nav>\n  )\n}\n')),(0,o.kt)("h2",{id:"improving-render-performance"},"Improving Render Performance"),(0,o.kt)("p",null,"Our application is looking useful, but we've actually got a couple flaws in when and how our components re-render. Let's look at those problems, and talk about some ways to improve the performance."),(0,o.kt)("h3",{id:"investigating-render-behavior"},"Investigating Render Behavior"),(0,o.kt)("p",null,"We can use the React DevTools Profiler to view some graphs of what components re-render when state is updated. Try clicking over to the ",(0,o.kt)("inlineCode",{parentName:"p"},"<UserPage>"),' for a single user. Open up your browser\'s DevTools, and in the React "Profiler" tab, click the circle "Record" button in the upper-left. Then, click the "Refresh Notifications" button in our app, and stop the recording in the React DevTools Profiler. You should see a chart that looks like this:'),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"React DevTools Profiler render capture - &lt;UserPage&gt;",src:n(3931).Z})),(0,o.kt)("p",null,"We can see that the ",(0,o.kt)("inlineCode",{parentName:"p"},"<Navbar>"),' re-rendered, which makes sense because it had to show the updated "unread notifications" badge in the tab. But, why did our ',(0,o.kt)("inlineCode",{parentName:"p"},"<UserPage>")," re-render?"),(0,o.kt)("p",null,"If we inspect the last couple dispatched actions in the Redux DevTools, we can see that only the notifications state updated. Since the ",(0,o.kt)("inlineCode",{parentName:"p"},"<UserPage>")," doesn't read any notifications, it shouldn't have re-rendered. Something must be wrong with the component."),(0,o.kt)("p",null,"If we look at ",(0,o.kt)("inlineCode",{parentName:"p"},"<UserPage>")," carefully, there's a specific problem:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/UserPage.js',title:'"features/UserPage.js'},"export const UserPage = ({ match }) => {\n  const { userId } = match.params\n\n  const user = useSelector(state => selectUserById(state, userId))\n\n  // highlight-start\n  const postsForUser = useSelector(state => {\n    const allPosts = selectAllPosts(state)\n    return allPosts.filter(post => post.user === userId)\n  })\n  // highlight-end\n\n  // omit rendering logic\n}\n")),(0,o.kt)("p",null,"We know that ",(0,o.kt)("inlineCode",{parentName:"p"},"useSelector")," will re-run every time an action is dispatched, and that it forces the component to re-render if we return a new reference value."),(0,o.kt)("p",null,"We're calling ",(0,o.kt)("inlineCode",{parentName:"p"},"filter()")," inside of our ",(0,o.kt)("inlineCode",{parentName:"p"},"useSelector")," hook, so that we only return the list of posts that belong to this user. Unfortunately, ",(0,o.kt)("strong",{parentName:"p"},"this means that ",(0,o.kt)("inlineCode",{parentName:"strong"},"useSelector")," ",(0,o.kt)("em",{parentName:"strong"},"always")," returns a new array reference, and so our component will re-render after ",(0,o.kt)("em",{parentName:"strong"},"every")," action even if the posts data hasn't changed!"),"."),(0,o.kt)("h3",{id:"memoizing-selector-functions"},"Memoizing Selector Functions"),(0,o.kt)("p",null,"What we really need is a way to only calculate the new filtered array if either ",(0,o.kt)("inlineCode",{parentName:"p"},"state.posts")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"userId")," have changed. If they ",(0,o.kt)("em",{parentName:"p"},"haven't")," changed, we want to return the same filtered array reference as the last time."),(0,o.kt)("p",null,'This idea is called "memoization". We want to save a previous set of inputs and the calculated result, and if the inputs are the same, return the previous result instead of recalculating it again.'),(0,o.kt)("p",null,"So far, we've been writing selector functions by ourselves, and just so that we don't have to copy and paste the code for reading data from the store. It would be great if there was a way to make our selector functions memoized."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"https://github.com/reduxjs/reselect"},"Reselect")," is a library for creating memoized selector functions"),", and was specifically designed to be used with Redux. It has a ",(0,o.kt)("inlineCode",{parentName:"p"},"createSelector")," function that generates memoized selectors that will only recalculate results when the inputs change. Redux Toolkit ",(0,o.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/createSelector"},"exports the ",(0,o.kt)("inlineCode",{parentName:"a"},"createSelector")," function"),", so we already have it available."),(0,o.kt)("p",null,"Let's make a new ",(0,o.kt)("inlineCode",{parentName:"p"},"selectPostsByUser")," selector function, using Reselect, and use it here."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="features/posts/postsSlice.js"',title:'"features/posts/postsSlice.js"'},"// highlight-next-line\nimport { createSlice, createAsyncThunk, createSelector } from '@reduxjs/toolkit'\n\n// omit slice logic\n\nexport const selectAllPosts = state => state.posts.posts\n\nexport const selectPostById = (state, postId) =>\n  state.posts.posts.find(post => post.id === postId)\n\n// highlight-start\nexport const selectPostsByUser = createSelector(\n  [selectAllPosts, (state, userId) => userId],\n  (posts, userId) => posts.filter(post => post.user === userId)\n)\n// highlight-end\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"createSelector"),' takes one or more "input selector" functions as argument, plus an "output selector" function. When we call ',(0,o.kt)("inlineCode",{parentName:"p"},"selectPostsByUser(state, userId)"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"createSelector")," will pass all of the arguments into each of our input selectors. Whatever those input selectors return becomes the arguments for the output selector."),(0,o.kt)("p",null,"In this case, we know that we need the array of all posts and the user ID as the two arguments for our output selector. We can reuse our existing ",(0,o.kt)("inlineCode",{parentName:"p"},"selectAllPosts")," selector to extract the posts array. Since the user ID is the second argument we're passing into ",(0,o.kt)("inlineCode",{parentName:"p"},"selectPostsByUser"),", we can write a small selector that just returns ",(0,o.kt)("inlineCode",{parentName:"p"},"userId"),"."),(0,o.kt)("p",null,"Our output selector then takes ",(0,o.kt)("inlineCode",{parentName:"p"},"posts")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"userId"),", and returns the filtered array of posts for just that user."),(0,o.kt)("p",null,"If we try calling ",(0,o.kt)("inlineCode",{parentName:"p"},"selectPostsByUser")," multiple times, it will only re-run the output selector if either ",(0,o.kt)("inlineCode",{parentName:"p"},"posts")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"userId")," has changed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const state1 = getState()\n// Output selector runs, because it's the first call\nselectPostsByUser(state1, 'user1')\n// Output selector does _not_ run, because the arguments haven't changed\nselectPostsByUser(state1, 'user1')\n// Output selector runs, because `userId` changed\nselectPostsByUser(state1, 'user2')\n\ndispatch(reactionAdded())\nconst state2 = getState()\n// Output selector does not run, because `posts` and `userId` are the same\nselectPostsByUser(state2, 'user2')\n\n// Add some more posts\ndispatch(addNewPost())\nconst state3 = getState()\n// Output selector runs, because `posts` has changed\nselectPostsByUser(state3, 'user2')\n")),(0,o.kt)("p",null,"If we call this selector in ",(0,o.kt)("inlineCode",{parentName:"p"},"<UserPage>")," and re-run the React profiler while fetching notifications, we should see that ",(0,o.kt)("inlineCode",{parentName:"p"},"<UserPage>")," doesn't re-render this time:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"export const UserPage = ({ match }) => {\n  const { userId } = match.params\n\n  const user = useSelector(state => selectUserById(state, userId))\n\n  // highlight-start\n  const postsForUser = useSelector(state => selectPostsByUser(state, userId))\n  // highlight-end\n\n  // omit rendering logic\n}\n")),(0,o.kt)("p",null,"Memoized selectors are a valuable tool for improving performance in a React+Redux application, because they can help us avoid unnecessary re-renders, and also avoid doing potentially complex or expensive calculations if the input data hasn't changed."),(0,o.kt)("h3",{id:"investigating-the-posts-list"},"Investigating the Posts List"),(0,o.kt)("p",null,"If we go back to our ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>")," and try clicking a reaction button on one of the posts while capturing a React profiler trace, we'll see that not only did the ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>")," and the updated ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostExcerpt>")," instance render, ",(0,o.kt)("em",{parentName:"p"},"all")," of the ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostExcerpt>")," components rendered:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"React DevTools Profiler render capture - &lt;PostsList&gt;",src:n(9979).Z})),(0,o.kt)("p",null,"Why is that? None of the other posts changed, so why would they need to re-render?"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/"},(0,o.kt)("strong",{parentName:"a"},"React's default behavior is that when a parent component renders, React will recursively render all child components inside of it!")),". The immutable update of one post object also created a new ",(0,o.kt)("inlineCode",{parentName:"p"},"posts")," array. Our ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>")," had to re-render because the ",(0,o.kt)("inlineCode",{parentName:"p"},"posts")," array was a new reference, so after it rendered, React continued downwards and re-rendered all of the ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostExcerpt>")," components too."),(0,o.kt)("p",null,"This isn't a serious problem for our small example app, but in a larger real-world app, we might have some very long lists or very large component trees, and having all those extra components re-render might slow things down."),(0,o.kt)("p",null,"There's a few different ways we could optimize this behavior in ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>"),"."),(0,o.kt)("p",null,"First, we could wrap the ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostExcerpt>")," component in ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/react-api.html#reactmemo"},(0,o.kt)("inlineCode",{parentName:"a"},"React.memo()")),", which will ensure that the component inside of it only re-renders if the props have actually changed. This will actually work quite well - try it out and see what happens:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/PostsList.js',title:'"features/posts/PostsList.js'},"// highlight-next-line\nlet PostExcerpt = ({ post }) => {\n  // omit logic\n}\n\n// highlight-next-line\nPostExcerpt = React.memo(PostExcerpt)\n")),(0,o.kt)("p",null,"Another option is to rewrite ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>")," so that it only selects a list of post IDs from the store instead of the entire ",(0,o.kt)("inlineCode",{parentName:"p"},"posts")," array, and rewrite ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostExcerpt>")," so that it receives a ",(0,o.kt)("inlineCode",{parentName:"p"},"postId")," prop and calls ",(0,o.kt)("inlineCode",{parentName:"p"},"useSelector")," to read the post object it needs. If ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>")," gets the same list of IDs as before, it won't need to re-render, and so only our one changed ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostExcerpt>")," component should have to render."),(0,o.kt)("p",null,"Unfortunately, this gets tricky because we also need to have all our posts sorted by date and rendered in the right order. We could update our ",(0,o.kt)("inlineCode",{parentName:"p"},"postsSlice")," to keep the array sorted at all times, so we don't have to sort it in the component, and use a memoized selector to extract just the list of post IDs. We could also ",(0,o.kt)("a",{parentName:"p",href:"https://react-redux.js.org/api/hooks#equality-comparisons-and-updates"},"customize the comparison function that ",(0,o.kt)("inlineCode",{parentName:"a"},"useSelector")," runs to check the results"),", like ",(0,o.kt)("inlineCode",{parentName:"p"},"useSelector(selectPostIds, shallowEqual)"),", so that will skip re-rendering if the ",(0,o.kt)("em",{parentName:"p"},"contents")," of the IDs array haven't changed."),(0,o.kt)("p",null,"The last option is to find some way to have our reducer keep a separate array of IDs for all the posts, and only modify that array when posts are added or removed, and do the same rewrite of ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostExcerpt>"),". This way, ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>")," only needs to re-render when that IDs array changes."),(0,o.kt)("p",null,"Conveniently, Redux Toolkit has a ",(0,o.kt)("inlineCode",{parentName:"p"},"createEntityAdapter")," function that will help us do just that."),(0,o.kt)("h2",{id:"normalizing-data"},"Normalizing Data"),(0,o.kt)("p",null,"You've seen that a lot of our logic has been looking up items by their ID field. Since we've been storing our data in arrays, that means we have to loop over all the items in the array using ",(0,o.kt)("inlineCode",{parentName:"p"},"array.find()")," until we find the item with the ID we're looking for."),(0,o.kt)("p",null,'Realistically, this doesn\'t take very long, but if we had arrays with hundreds or thousands of items inside, looking through the entire array to find one item becomes wasted effort. What we need is a way to look up a single item based on its ID, directly, without having to check all the other items. This process is known as "normalization".'),(0,o.kt)("h3",{id:"normalized-state-structure"},"Normalized State Structure"),(0,o.kt)("p",null,'"Normalized state" means that:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"We only have one copy of each particular piece of data in our state, so there's no duplication"),(0,o.kt)("li",{parentName:"ul"},"Data that has been normalized is kept in a lookup table, where the item IDs are the keys, and the items themselves are the values."),(0,o.kt)("li",{parentName:"ul"},"There may also be an array of all of the IDs for a particular item type")),(0,o.kt)("p",null,'JavaScript objects can be used as lookup tables, similar to "maps" or "dictionaries" in other languages. Here\'s what the normalized state for a group of ',(0,o.kt)("inlineCode",{parentName:"p"},"user")," objects might look like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'{\n  users: {\n    ids: ["user1", "user2", "user3"],\n    entities: {\n      "user1": {id: "user1", firstName, lastName},\n      "user2": {id: "user2", firstName, lastName},\n      "user3": {id: "user3", firstName, lastName},\n    }\n  }\n}\n')),(0,o.kt)("p",null,"This makes it easy to find a particular ",(0,o.kt)("inlineCode",{parentName:"p"},"user")," object by its ID, without having to loop through all the other user objects in an array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const userId = 'user2'\nconst userObject = state.users.entities[userId]\n")),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"\u8bf4\u660e")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"For more details on why normalizing state is useful, see ",(0,o.kt)("a",{parentName:"p",href:"/redux-in-chinese/recipes/structuring-reducers/normalizing-state-shape"},"Normalizing State Shape")," and the Redux Toolkit Usage Guide section on ",(0,o.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/usage/usage-guide#managing-normalized-data"},"Managing Normalized Data"),"."))),(0,o.kt)("h3",{id:"managing-normalized-state-with-createentityadapter"},"Managing Normalized State with ",(0,o.kt)("inlineCode",{parentName:"h3"},"createEntityAdapter")),(0,o.kt)("p",null,"Redux Toolkit's ",(0,o.kt)("inlineCode",{parentName:"p"},"createEntityAdapter")," API provides a standardized way to store your data in a slice by taking a collection of items and putting them into the shape of ",(0,o.kt)("inlineCode",{parentName:"p"},"{ ids: [], entities: {} }"),". Along with this predefined state shape, it generates a set of reducer functions and selectors that know how to work with that data."),(0,o.kt)("p",null,"This has several benefits:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"We don't have to write the code to manage the normalization ourselves"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"createEntityAdapter"),'\'s pre-built reducer functions handle common cases like "add all these items", "update one item", or "remove multiple items"'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"createEntityAdapter")," can keep the ID array in a sorted order based on the contents of the items, and will only update that array if items are added / removed or the sorting order changes.")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"createEntityAdapter")," accepts an options object that may include a ",(0,o.kt)("inlineCode",{parentName:"p"},"sortComparer")," function, which will be used to keep the item IDs array in sorted order by comparing two items (and works the same way as ",(0,o.kt)("inlineCode",{parentName:"p"},"Array.sort()"),")."),(0,o.kt)("p",null,"It returns an object that contains ",(0,o.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/createEntityAdapter#crud-functions"},"a set of generated reducer functions for adding, updating, and removing items from an entity state object"),'. These reducer functions can either be used as a case reducer for a specific action type, or as a "mutating" utility function within another reducer in ',(0,o.kt)("inlineCode",{parentName:"p"},"createSlice"),"."),(0,o.kt)("p",null,"The adapter object also has a ",(0,o.kt)("inlineCode",{parentName:"p"},"getSelectors")," function. You can pass in a selector that returns this particular slice of state from the Redux root state, and it will generate selectors like ",(0,o.kt)("inlineCode",{parentName:"p"},"selectAll")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"selectById"),"."),(0,o.kt)("p",null,"Finally, the adapter object has a ",(0,o.kt)("inlineCode",{parentName:"p"},"getInitialState")," function that generates an empty ",(0,o.kt)("inlineCode",{parentName:"p"},"{ids: [], entities: {}}")," object. You can pass in more fields to ",(0,o.kt)("inlineCode",{parentName:"p"},"getInitialState"),", and those will be merged in."),(0,o.kt)("h3",{id:"updating-the-posts-slice"},"Updating the Posts Slice"),(0,o.kt)("p",null,"With that in mind, let's update our ",(0,o.kt)("inlineCode",{parentName:"p"},"postsSlice")," to use ",(0,o.kt)("inlineCode",{parentName:"p"},"createEntityAdapter"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="features/posts/postsSlice.js"',title:'"features/posts/postsSlice.js"'},"import {\n  // highlight-next-line\n  createEntityAdapter\n  // omit other imports\n} from '@reduxjs/toolkit'\n\n// highlight-start\nconst postsAdapter = createEntityAdapter({\n  sortComparer: (a, b) => b.date.localeCompare(a.date)\n})\n\nconst initialState = postsAdapter.getInitialState({\n  status: 'idle',\n  error: null\n})\n// highlight-end\n\n// omit thunks\n\nconst postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    reactionAdded(state, action) {\n      const { postId, reaction } = action.payload\n      // highlight-next-line\n      const existingPost = state.entities[postId]\n      if (existingPost) {\n        existingPost.reactions[reaction]++\n      }\n    },\n    postUpdated(state, action) {\n      const { id, title, content } = action.payload\n      // highlight-next-line\n      const existingPost = state.entities[id]\n      if (existingPost) {\n        existingPost.title = title\n        existingPost.content = content\n      }\n    }\n  },\n  extraReducers: {\n    // omit other reducers\n\n    [fetchPosts.fulfilled]: (state, action) => {\n      state.status = 'succeeded'\n      // Add any fetched posts to the array\n      // highlight-start\n      // Use the `upsertMany` reducer as a mutating update utility\n      postsAdapter.upsertMany(state, action.payload)\n      // highlight-end\n    },\n    // highlight-start\n    // Use the `addOne` reducer for the fulfilled case\n    [addNewPost.fulfilled]: postsAdapter.addOne\n    // highlight-end\n  }\n})\n\nexport const { postAdded, postUpdated, reactionAdded } = postsSlice.actions\n\nexport default postsSlice.reducer\n\n// highlight-start\n// Export the customized selectors for this adapter using `getSelectors`\nexport const {\n  selectAll: selectAllPosts,\n  selectById: selectPostById,\n  selectIds: selectPostIds\n  // Pass in a selector that returns the posts slice of state\n} = postsAdapter.getSelectors(state => state.posts)\n// highlight-end\n\nexport const selectPostsByUser = createSelector(\n  [selectAllPosts, (state, userId) => userId],\n  (posts, userId) => posts.filter(post => post.user === userId)\n)\n")),(0,o.kt)("p",null,"There's a lot going on there! Let's break it down."),(0,o.kt)("p",null,"First, we import ",(0,o.kt)("inlineCode",{parentName:"p"},"createEntityAdapter"),", and call it to create our ",(0,o.kt)("inlineCode",{parentName:"p"},"postsAdapter")," object. We know that we want to keep an array of all post IDs sorted with the newest post first, so we pass in a ",(0,o.kt)("inlineCode",{parentName:"p"},"sortComparer")," function that will sort newer items to the front based on the ",(0,o.kt)("inlineCode",{parentName:"p"},"post.date")," field."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"getInitialState()")," returns an empty ",(0,o.kt)("inlineCode",{parentName:"p"},"{ids: [], entities: {}}")," normalized state object. Our ",(0,o.kt)("inlineCode",{parentName:"p"},"postsSlice")," needs to keep the ",(0,o.kt)("inlineCode",{parentName:"p"},"status")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"error")," fields for loading state too, so we pass those in to ",(0,o.kt)("inlineCode",{parentName:"p"},"getInitialState()"),"."),(0,o.kt)("p",null,"Now that our posts are being kept as a lookup table in ",(0,o.kt)("inlineCode",{parentName:"p"},"state.entities"),", we can change our ",(0,o.kt)("inlineCode",{parentName:"p"},"reactionAdded")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"postUpdated")," reducers to directly look up the right posts by their IDs, instead of having to loop over the old ",(0,o.kt)("inlineCode",{parentName:"p"},"posts")," array."),(0,o.kt)("p",null,"When we receive the ",(0,o.kt)("inlineCode",{parentName:"p"},"fetchPosts.fulfilled")," action, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"postsAdapter.upsertMany")," function to add all of the incoming posts to the state, by passing in the draft ",(0,o.kt)("inlineCode",{parentName:"p"},"state")," and the array of posts in ",(0,o.kt)("inlineCode",{parentName:"p"},"action.payload"),". If there's any items in ",(0,o.kt)("inlineCode",{parentName:"p"},"action.payload")," that already existing in our state, the ",(0,o.kt)("inlineCode",{parentName:"p"},"upsertMany")," function will merge them together based on matching IDs."),(0,o.kt)("p",null,"When we receive the ",(0,o.kt)("inlineCode",{parentName:"p"},"addNewPost.fulfilled")," action, we know we need to add that one new post object to our state. We can use the adapter functions as reducers directly, so we'll pass ",(0,o.kt)("inlineCode",{parentName:"p"},"postsAdapter.addOne")," as the reducer function to use to handle that action."),(0,o.kt)("p",null,"Finally, we can replace the old hand-written ",(0,o.kt)("inlineCode",{parentName:"p"},"selectAllPosts")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"selectPostById")," selector functions with the ones generated by ",(0,o.kt)("inlineCode",{parentName:"p"},"postsAdapter.getSelectors"),". Since the selectors are called with the root Redux state object, they need to know where to find our posts data in the Redux state, so we pass in a small selector that returns ",(0,o.kt)("inlineCode",{parentName:"p"},"state.posts"),". The generated selector functions are always called ",(0,o.kt)("inlineCode",{parentName:"p"},"selectAll")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"selectById"),", so we can use ES6 destructuring syntax to rename them as we export them and match the old selector names. We'll also export ",(0,o.kt)("inlineCode",{parentName:"p"},"selectPostIds")," the same way, since we want to read the list of sorted post IDs in our ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>")," component."),(0,o.kt)("h3",{id:"optimizing-the-posts-list"},"Optimizing the Posts List"),(0,o.kt)("p",null,"Now that our posts slice is using ",(0,o.kt)("inlineCode",{parentName:"p"},"createEntityAdapter"),", we can update ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>")," to optimize its rendering behavior."),(0,o.kt)("p",null,"We'll update ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostsList>")," to read just the sorted array of post IDs, and pass ",(0,o.kt)("inlineCode",{parentName:"p"},"postId")," to each ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostExcerpt>"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="features/posts/PostsList.js"',title:'"features/posts/PostsList.js"'},"// omit other imports\n\n// highlight-start\nimport {\n  selectAllPosts,\n  fetchPosts,\n  selectPostIds,\n  selectPostById\n} from './postsSlice'\n\nlet PostExcerpt = ({ postId }) => {\n  const post = useSelector(state => selectPostById(state, postId))\n  // highlight-end\n  // omit rendering logic\n}\n\nexport const PostsList = () => {\n  const dispatch = useDispatch()\n  // highlight-next-line\n  const orderedPostIds = useSelector(selectPostIds)\n\n  // omit other selections and effects\n\n  if (postStatus === 'loading') {\n    content = <div className=\"loader\">Loading...</div>\n  } else if (postStatus === 'succeeded') {\n    // highlight-start\n    content = orderedPostIds.map(postId => (\n      <PostExcerpt key={postId} postId={postId} />\n    ))\n    // highlight-end\n  } else if (postStatus === 'error') {\n    content = <div>{error}</div>\n  }\n\n  // omit other rendering\n}\n")),(0,o.kt)("p",null,"Now, if we try clicking a reaction button on one of the posts while capturing a React component performance profile, we should see that ",(0,o.kt)("em",{parentName:"p"},"only")," that one component re-rendered:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"React DevTools Profiler render capture - optimized &lt;PostsList&gt;",src:n(1201).Z})),(0,o.kt)("h2",{id:"converting-other-slices"},"Converting Other Slices"),(0,o.kt)("p",null,"We're almost done. As a final cleanup step, we'll update our other two slices to use ",(0,o.kt)("inlineCode",{parentName:"p"},"createEntityAdapter")," as well."),(0,o.kt)("h3",{id:"converting-the-users-slice"},"Converting the Users Slice"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"usersSlice")," is fairly small, so we've only got a few things to change:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="features/users/usersSlice.js"',title:'"features/users/usersSlice.js"'},"import {\n  createSlice,\n  createAsyncThunk,\n  // highlight-next-line\n  createEntityAdapter\n} from '@reduxjs/toolkit'\nimport { client } from '../../api/client'\n\n// highlight-start\nconst usersAdapter = createEntityAdapter()\n\nconst initialState = usersAdapter.getInitialState()\n// highlight-end\n\nexport const fetchUsers = createAsyncThunk('users/fetchUsers', async () => {\n  const response = await client.get('/fakeApi/users')\n  return response.users\n})\n\nconst usersSlice = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {},\n  extraReducers: {\n    // highlight-next-line\n    [fetchUsers.fulfilled]: usersAdapter.setAll\n  }\n})\n\nexport default usersSlice.reducer\n\n// highlight-start\nexport const { selectAll: selectAllUsers, selectById: selectUserById } =\n  usersAdapter.getSelectors(state => state.users)\n// highlight-end\n")),(0,o.kt)("p",null,"The only action we're handling here always replaces the entire list of users with the array we fetched from the server. We can use ",(0,o.kt)("inlineCode",{parentName:"p"},"usersAdapter.setAll")," to implement that instead."),(0,o.kt)("p",null,"Our ",(0,o.kt)("inlineCode",{parentName:"p"},"<AddPostForm>")," is still trying to read ",(0,o.kt)("inlineCode",{parentName:"p"},"state.users")," as an array, as is ",(0,o.kt)("inlineCode",{parentName:"p"},"<PostAuthor>"),". Update them to use ",(0,o.kt)("inlineCode",{parentName:"p"},"selectAllUsers")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"selectUserById"),", respectively."),(0,o.kt)("h3",{id:"converting-the-notifications-slice"},"Converting the Notifications Slice"),(0,o.kt)("p",null,"Last but not least, we'll update ",(0,o.kt)("inlineCode",{parentName:"p"},"notificationsSlice")," as well:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="features/notifications/notificationsSlice.js"',title:'"features/notifications/notificationsSlice.js"'},"import {\n  createSlice,\n  createAsyncThunk,\n  // highlight-next-line\n  createEntityAdapter\n} from '@reduxjs/toolkit'\n\nimport { client } from '../../api/client'\n\n// highlight-start\nconst notificationsAdapter = createEntityAdapter({\n  sortComparer: (a, b) => b.date.localeCompare(a.date)\n})\n// highlight-end\n\n// omit fetchNotifications thunk\n\nconst notificationsSlice = createSlice({\n  name: 'notifications',\n  // highlight-next-line\n  initialState: notificationsAdapter.getInitialState(),\n  reducers: {\n    allNotificationsRead(state, action) {\n      // highlight-start\n      Object.values(state.entities).forEach(notification => {\n        notification.read = true\n      })\n      // highlight-end\n    }\n  },\n  extraReducers: {\n    [fetchNotifications.fulfilled]: (state, action) => {\n      // highlight-start\n      Object.values(state.entities).forEach(notification => {\n        // Any notifications we've read are no longer new\n        notification.isNew = !notification.read\n      })\n      notificationsAdapter.upsertMany(state, action.payload)\n      // highlight-end\n    }\n  }\n})\n\nexport const { allNotificationsRead } = notificationsSlice.actions\n\nexport default notificationsSlice.reducer\n\n// highlight-start\nexport const { selectAll: selectAllNotifications } =\n  notificationsAdapter.getSelectors(state => state.notifications)\n// highlight-end\n")),(0,o.kt)("p",null,"We again import ",(0,o.kt)("inlineCode",{parentName:"p"},"createEntityAdapter"),", call it, and call ",(0,o.kt)("inlineCode",{parentName:"p"},"notificationsAdapter.getInitialState()")," to help set up the slice."),(0,o.kt)("p",null,"Ironically, we do have a couple places in here where we need to loop over all notification objects and update them. Since those are no longer being kept in an array, we have to use ",(0,o.kt)("inlineCode",{parentName:"p"},"Object.values(state.entities)")," to get an array of those notifications and loop over that. On the other hand, we can replace the previous fetch update logic with ",(0,o.kt)("inlineCode",{parentName:"p"},"notificationsAdapter.upsertMany"),"."),(0,o.kt)("p",null,"And with that... we're done!"),(0,o.kt)("h2",{id:"\u4f60\u5b66\u5230\u4e86"},"\u4f60\u5b66\u5230\u4e86"),(0,o.kt)("p",null,"Congratulations, you've completed the Redux Essentials tutorial! Let's see what the final app looks like in action:"),(0,o.kt)("iframe",{class:"codesandbox",src:"https://codesandbox.io/embed/github/reduxjs/redux-essentials-example-app/tree/checkpoint-4-entitySlices/?fontsize=14&hidenavigation=1&theme=dark&runonclick=1",title:"redux-essentials-example-app",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),(0,o.kt)("p",null,"Here's what we covered in this section:"),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"\u603b\u7ed3")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("ul",{parentName:"div"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Memoized selector functions can be used to optimize performance"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Redux Toolkit re-exports the ",(0,o.kt)("inlineCode",{parentName:"li"},"createSelector")," function from Reselect, which generates memoized selectors"),(0,o.kt)("li",{parentName:"ul"},"Memoized selectors will only recalculate the results if the input selectors return new values"),(0,o.kt)("li",{parentName:"ul"},"Memoization can skip expensive calculations, and ensure the same result references are returned"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"There are multiple patterns you can use to optimize React component rendering with Redux"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Avoid creating new object/array references inside of ",(0,o.kt)("inlineCode",{parentName:"li"},"useSelector")," - those will cause unnecessary re-renders"),(0,o.kt)("li",{parentName:"ul"},"Memoized selector functions can be passed to ",(0,o.kt)("inlineCode",{parentName:"li"},"useSelector")," to optimize rendering"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"useSelector")," can accept an alternate comparison function like ",(0,o.kt)("inlineCode",{parentName:"li"},"shallowEqual")," instead of reference equality"),(0,o.kt)("li",{parentName:"ul"},"Components can be wrapped in ",(0,o.kt)("inlineCode",{parentName:"li"},"React.memo()")," to only re-render if their props change"),(0,o.kt)("li",{parentName:"ul"},"List rendering can be optimized by having list parent components read just an array of item IDs, passing the IDs to list item children, and retrieving items by ID in the children"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Normalized state structure is a recommended approach for storing items"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},'"Normalization" means no duplication of data, and keeping items stored in a lookup table by item ID'),(0,o.kt)("li",{parentName:"ul"},"Normalized state shape usually looks like ",(0,o.kt)("inlineCode",{parentName:"li"},"{ids: [], entities: {}}")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Redux Toolkit's ",(0,o.kt)("inlineCode",{parentName:"strong"},"createEntityAdapter")," API helps manage normalized data in a slice"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Item IDs can be kept in sorted order by passing in a ",(0,o.kt)("inlineCode",{parentName:"li"},"sortComparer")," option"),(0,o.kt)("li",{parentName:"ul"},"The adapter object includes:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"adapter.getInitialState"),", which can accept additional state fields like loading state"),(0,o.kt)("li",{parentName:"ul"},"Prebuilt reducers for common cases, like ",(0,o.kt)("inlineCode",{parentName:"li"},"setAll"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"addMany"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"upsertOne"),", and ",(0,o.kt)("inlineCode",{parentName:"li"},"removeMany")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"adapter.getSelectors"),", which generates selectors like ",(0,o.kt)("inlineCode",{parentName:"li"},"selectAll")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"selectById"))))))))),(0,o.kt)("h2",{id:"\u4e0b\u4e00\u6b65"},"\u4e0b\u4e00\u6b65"),(0,o.kt)("p",null,"The concepts we've covered in this tutorial should be enough to get you started building your own applications using React and Redux. Now's a great time to try working on a project yourself to solidify these concepts and see how they work in practice. If you're not sure what kind of a project to build, see ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/florinpop17/app-ideas"},"this list of app project ideas")," for some inspiration."),(0,o.kt)("p",null,'The Redux Essentials tutorial focused on "how to use Redux correctly", rather than "how it works" or "why it works this way". In particular, Redux Toolkit is a higher-level set of abstractions and utilities, and it\'s helpful to understand what the abstractions in RTK are actually doing for you. Reading through the ',(0,o.kt)("a",{parentName:"p",href:"/redux-in-chinese/tutorials/fundamentals/part-1-overview"},'"Redux Fundamentals" tutorial'),' will help you understand how to write Redux code "by hand", and why we recommend Redux Toolkit as the default way to write Redux logic.'),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/redux-in-chinese/recipes/recipe-index"},"Recipes")," section has information on a number of important concepts, like ",(0,o.kt)("a",{parentName:"p",href:"/redux-in-chinese/recipes/structuring-reducers/structuring-reducers"},"how to structure your reducers"),", and ",(0,o.kt)("a",{parentName:"p",href:"../../style-guide/style-guide"},"our Style Guide page")," has important information on our recommended patterns and best practices."),(0,o.kt)("p",null,"If you'd like to know more about ",(0,o.kt)("em",{parentName:"p"},"why")," Redux exists, what problems it tries to solve, and how it's meant to be used, see Redux maintainer Mark Erikson's posts on ",(0,o.kt)("a",{parentName:"p",href:"https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/"},"The Tao of Redux, Part 1: Implementation and Intent")," and ",(0,o.kt)("a",{parentName:"p",href:"https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/"},"The Tao of Redux, Part 2: Practice and Philosophy"),"."),(0,o.kt)("p",null,"If you're looking for help with Redux questions, come join ",(0,o.kt)("a",{parentName:"p",href:"https://www.reactiflux.com"},"the ",(0,o.kt)("inlineCode",{parentName:"a"},"#redux")," channel in the Reactiflux server on Discord"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"\u611f\u8c22\u60a8\u9605\u8bfb\u672c\u6559\u7a0b\uff0c\u6211\u4eec\u5e0c\u671b\u60a8\u559c\u6b22\u4f7f\u7528 Redux \u6784\u5efa\u5e94\u7528\u7a0b\u5e8f\uff01")))}p.isMDXComponent=!0},8627:function(e,t,n){"use strict";t.Z=n.p+"assets/images/notifications-initial-78eeb6d749f8287ebebe6a8b4e28efae.png"},7585:function(e,t,n){"use strict";t.Z=n.p+"assets/images/notifications-new-47a4cee8ef5292cc65a8b4b89245c112.png"},1201:function(e,t,n){"use strict";t.Z=n.p+"assets/images/postslist-optimized-dcf59b403248250ec88d365fe04221ad.png"},9979:function(e,t,n){"use strict";t.Z=n.p+"assets/images/postslist-rerender-cf83ea2e96266af8ce3027d614f0c574.png"},3931:function(e,t,n){"use strict";t.Z=n.p+"assets/images/userpage-rerender-d064bb5a9461960f5949ba996597c3f7.png"}}]);