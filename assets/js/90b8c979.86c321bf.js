(self.webpackChunk=self.webpackChunk||[]).push([[6081],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return l},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),c=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=c(e.components);return a.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),h=c(n),u=r,m=h["".concat(d,".").concat(u)]||h[u]||p[u]||i;return n?a.createElement(m,o(o({ref:t},l),{},{components:n})):a.createElement(m,o({ref:t},l))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1094:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},metadata:function(){return s},toc:function(){return d},default:function(){return l}});var a=n(2122),r=n(9756),i=(n(7294),n(3905)),o={id:"applymiddleware",title:"applyMiddleware",hide_title:!0},s={unversionedId:"api/applymiddleware",id:"api/applymiddleware",isDocsHomePage:!1,title:"applyMiddleware",description:"Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's dispatch method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.",source:"@site/../docs/api/applyMiddleware.md",sourceDirName:"api",slug:"/api/applymiddleware",permalink:"/redux-in-chinese/api/applymiddleware",version:"current",frontMatter:{id:"applymiddleware",title:"applyMiddleware",hide_title:!0},sidebar:"docs",previous:{title:"combineReducers",permalink:"/redux-in-chinese/api/combinereducers"},next:{title:"bindActionCreators",permalink:"/redux-in-chinese/api/bindactioncreators"}},d=[],c={toc:d};function l(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"applymiddlewaremiddleware"},(0,i.kt)("inlineCode",{parentName:"h1"},"applyMiddleware(...middleware)")),(0,i.kt)("p",null,"Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/api/store#dispatchaction"},(0,i.kt)("inlineCode",{parentName:"a"},"dispatch"))," method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain."),(0,i.kt)("p",null,"The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Reactive-Extensions/RxJS"},"Rx"),". It does so by letting you dispatch ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/understanding/thinking-in-redux/glossary#async-action"},"async actions")," in addition to normal actions."),(0,i.kt)("p",null,"For example, ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/gaearon/redux-thunk"},"redux-thunk")," lets the action creators invert control by dispatching functions. They would receive ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/api/store#dispatchaction"},(0,i.kt)("inlineCode",{parentName:"a"},"dispatch"))," as an argument and may call it asynchronously. Such functions are called ",(0,i.kt)("em",{parentName:"p"},"thunks"),". Another example of middleware is ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/acdlite/redux-promise"},"redux-promise"),". It lets you dispatch a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise"},"Promise")," async action, and dispatches a normal action when the Promise resolves."),(0,i.kt)("p",null,"Middleware is not baked into ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/api/createstore"},(0,i.kt)("inlineCode",{parentName:"a"},"createStore"))," and is not a fundamental part of the Redux architecture, but we consider it useful enough to be supported right in the core. This way, there is a single standard way to extend ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/api/store#dispatchaction"},(0,i.kt)("inlineCode",{parentName:"a"},"dispatch"))," in the ecosystem, and different middleware may compete in expressiveness and utility."),(0,i.kt)("h4",{id:"arguments"},"Arguments"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"...middleware")," (",(0,i.kt)("em",{parentName:"li"},"arguments"),"): Functions that conform to the Redux ",(0,i.kt)("em",{parentName:"li"},"middleware API"),". Each middleware receives ",(0,i.kt)("a",{parentName:"li",href:"/redux-in-chinese/api/store"},(0,i.kt)("inlineCode",{parentName:"a"},"Store")),"'s ",(0,i.kt)("a",{parentName:"li",href:"/redux-in-chinese/api/store#dispatchaction"},(0,i.kt)("inlineCode",{parentName:"a"},"dispatch"))," and ",(0,i.kt)("a",{parentName:"li",href:"/redux-in-chinese/api/store#getState"},(0,i.kt)("inlineCode",{parentName:"a"},"getState"))," functions as named arguments, and returns a function. That function will be given the ",(0,i.kt)("inlineCode",{parentName:"li"},"next")," middleware's dispatch method, and is expected to return a function of ",(0,i.kt)("inlineCode",{parentName:"li"},"action")," calling ",(0,i.kt)("inlineCode",{parentName:"li"},"next(action)")," with a potentially different argument, or at a different time, or maybe not calling it at all. The last middleware in the chain will receive the real store's ",(0,i.kt)("a",{parentName:"li",href:"/redux-in-chinese/api/store#dispatchaction"},(0,i.kt)("inlineCode",{parentName:"a"},"dispatch"))," method as the ",(0,i.kt)("inlineCode",{parentName:"li"},"next")," parameter, thus ending the chain. So, the middleware signature is ",(0,i.kt)("inlineCode",{parentName:"li"},"({ getState, dispatch }) => next => action"),".")),(0,i.kt)("h4",{id:"returns"},"Returns"),(0,i.kt)("p",null,"(",(0,i.kt)("em",{parentName:"p"},"Function"),") A store enhancer that applies the given middleware. The store enhancer signature is ",(0,i.kt)("inlineCode",{parentName:"p"},"createStore => createStore")," but the easiest way to apply it is to pass it to ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/api/createstore"},(0,i.kt)("inlineCode",{parentName:"a"},"createStore()"))," as the last ",(0,i.kt)("inlineCode",{parentName:"p"},"enhancer")," argument."),(0,i.kt)("h4",{id:"example-custom-logger-middleware"},"Example: Custom Logger Middleware"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createStore, applyMiddleware } from 'redux'\nimport todos from './reducers'\n\nfunction logger({ getState }) {\n  return next => action => {\n    console.log('will dispatch', action)\n\n    // Call the next dispatch method in the middleware chain.\n    const returnValue = next(action)\n\n    console.log('state after dispatch', getState())\n\n    // This will likely be the action itself, unless\n    // a middleware further in chain changed it.\n    return returnValue\n  }\n}\n\nconst store = createStore(todos, ['Use Redux'], applyMiddleware(logger))\n\nstore.dispatch({\n  type: 'ADD_TODO',\n  text: 'Understand the middleware'\n})\n// (These lines will be logged by the middleware:)\n// will dispatch: { type: 'ADD_TODO', text: 'Understand the middleware' }\n// state after dispatch: [ 'Use Redux', 'Understand the middleware' ]\n")),(0,i.kt)("h4",{id:"example-using-thunk-middleware-for-async-actions"},"Example: Using Thunk Middleware for Async Actions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createStore, combineReducers, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\nimport * as reducers from './reducers'\n\nconst reducer = combineReducers(reducers)\n// applyMiddleware supercharges createStore with middleware:\nconst store = createStore(reducer, applyMiddleware(thunk))\n\nfunction fetchSecretSauce() {\n  return fetch('https://www.google.com/search?q=secret+sauce')\n}\n\n// These are the normal action creators you have seen so far.\n// The actions they return can be dispatched without any middleware.\n// However, they only express \u201cfacts\u201d and not the \u201casync flow\u201d.\nfunction makeASandwich(forPerson, secretSauce) {\n  return {\n    type: 'MAKE_SANDWICH',\n    forPerson,\n    secretSauce\n  }\n}\n\nfunction apologize(fromPerson, toPerson, error) {\n  return {\n    type: 'APOLOGIZE',\n    fromPerson,\n    toPerson,\n    error\n  }\n}\n\nfunction withdrawMoney(amount) {\n  return {\n    type: 'WITHDRAW',\n    amount\n  }\n}\n\n// Even without middleware, you can dispatch an action:\nstore.dispatch(withdrawMoney(100))\n\n// But what do you do when you need to start an asynchronous action,\n// such as an API call, or a router transition?\n\n// Meet thunks.\n// A thunk is a function that returns a function.\n// This is a thunk.\nfunction makeASandwichWithSecretSauce(forPerson) {\n  // Invert control!\n  // Return a function that accepts `dispatch` so we can dispatch later.\n  // Thunk middleware knows how to turn thunk async actions into actions.\n  return function (dispatch) {\n    return fetchSecretSauce().then(\n      sauce => dispatch(makeASandwich(forPerson, sauce)),\n      error => dispatch(apologize('The Sandwich Shop', forPerson, error))\n    )\n  }\n}\n\n// Thunk middleware lets me dispatch thunk async actions\n// as if they were actions!\nstore.dispatch(makeASandwichWithSecretSauce('Me'))\n\n// It even takes care to return the thunk's return value\n// from the dispatch, so I can chain Promises as long as I return them.\nstore.dispatch(makeASandwichWithSecretSauce('My wife')).then(() => {\n  console.log('Done!')\n})\n\n// In fact I can write action creators that dispatch\n// actions and async actions from other action creators,\n// and I can build my control flow with Promises.\nfunction makeSandwichesForEverybody() {\n  return function (dispatch, getState) {\n    if (!getState().sandwiches.isShopOpen) {\n      // You don't have to return Promises, but it's a handy convention\n      // so the caller can always call .then() on async dispatch result.\n      return Promise.resolve()\n    }\n\n    // We can dispatch both plain object actions and other thunks,\n    // which lets us compose the asynchronous actions in a single flow.\n    return dispatch(makeASandwichWithSecretSauce('My Grandma'))\n      .then(() =>\n        Promise.all([\n          dispatch(makeASandwichWithSecretSauce('Me')),\n          dispatch(makeASandwichWithSecretSauce('My wife'))\n        ])\n      )\n      .then(() => dispatch(makeASandwichWithSecretSauce('Our kids')))\n      .then(() =>\n        dispatch(\n          getState().myMoney > 42\n            ? withdrawMoney(42)\n            : apologize('Me', 'The Sandwich Shop')\n        )\n      )\n  }\n}\n\n// This is very useful for server side rendering, because I can wait\n// until data is available, then synchronously render the app.\n\nimport { renderToString } from 'react-dom/server'\n\nstore\n  .dispatch(makeSandwichesForEverybody())\n  .then(() => response.send(renderToString(<MyApp store={store} />)))\n\n// I can also dispatch a thunk async action from a component\n// any time its props change to load the missing data.\n\nimport { connect } from 'react-redux'\nimport { Component } from 'react'\n\nclass SandwichShop extends Component {\n  componentDidMount() {\n    this.props.dispatch(makeASandwichWithSecretSauce(this.props.forPerson))\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.forPerson !== this.props.forPerson) {\n      this.props.dispatch(makeASandwichWithSecretSauce(this.props.forPerson))\n    }\n  }\n\n  render() {\n    return <p>{this.props.sandwiches.join('mustard')}</p>\n  }\n}\n\nexport default connect(state => ({\n  sandwiches: state.sandwiches\n}))(SandwichShop)\n")),(0,i.kt)("h4",{id:"tips"},"Tips"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Middleware only wraps the store's ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/api/store#dispatchaction"},(0,i.kt)("inlineCode",{parentName:"a"},"dispatch"))," function. Technically, anything a middleware can do, you can do manually by wrapping every ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch")," call, but it's easier to manage this in a single place and define action transformations on the scale of the whole project.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If you use other store enhancers in addition to ",(0,i.kt)("inlineCode",{parentName:"p"},"applyMiddleware"),", make sure to put ",(0,i.kt)("inlineCode",{parentName:"p"},"applyMiddleware")," before them in the composition chain because the middleware is potentially asynchronous. For example, it should go before ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-devtools"},"redux-devtools")," because otherwise the DevTools won't see the raw actions emitted by the Promise middleware and such.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If you want to conditionally apply a middleware, make sure to only import it when it's needed:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let middleware = [a, b]\nif (process.env.NODE_ENV !== 'production') {\n  const c = require('some-debug-middleware')\n  const d = require('another-debug-middleware')\n  middleware = [...middleware, c, d]\n}\n\nconst store = createStore(\n  reducer,\n  preloadedState,\n  applyMiddleware(...middleware)\n)\n")),(0,i.kt)("p",{parentName:"li"},"This makes it easier for bundling tools to cut out unneeded modules and reduces the size of your builds.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Ever wondered what ",(0,i.kt)("inlineCode",{parentName:"p"},"applyMiddleware")," itself is? It ought to be an extension mechanism more powerful than the middleware itself. Indeed, ",(0,i.kt)("inlineCode",{parentName:"p"},"applyMiddleware")," is an example of the most powerful Redux extension mechanism called ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/understanding/thinking-in-redux/glossary#store-enhancer"},"store enhancers"),". It is highly unlikely you'll ever want to write a store enhancer yourself. Another example of a store enhancer is ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-devtools"},"redux-devtools"),". Middleware is less powerful than a store enhancer, but it is easier to write.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Middleware sounds much more complicated than it really is. The only way to really understand middleware is to see how the existing middleware works, and try to write your own. The function nesting can be intimidating, but most of the middleware you'll find are, in fact, 10-liners, and the nesting and composability is what makes the middleware system powerful.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To apply multiple store enhancers, you may use ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/api/compose"},(0,i.kt)("inlineCode",{parentName:"a"},"compose()")),"."))))}l.isMDXComponent=!0}}]);