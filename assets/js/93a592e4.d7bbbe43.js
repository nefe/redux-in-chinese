(self.webpackChunk=self.webpackChunk||[]).push([[2592],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=d(n),h=o,m=u["".concat(l,".").concat(h)]||u[h]||p[h]||i;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var d=2;d<i;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5778:function(e,t,n){"use strict";n.d(t,{s:function(){return o}});var a=n(7294),o=function(e){var t=e.children,n=e.title,o=void 0===n?"Detailed Explanation":n;return a.createElement("details",{className:"detailed-explanation"},a.createElement("summary",null,a.createElement("h4",null,o)),t)}},6174:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return r},metadata:function(){return l},toc:function(){return d},default:function(){return p}});var a=n(2122),o=n(9756),i=(n(7294),n(3905)),s=n(5778),r={id:"part-7-standard-patterns",title:"Redux Fundamentals, Part 7: Standard Redux Patterns",sidebar_label:"Standard Redux Patterns",hide_title:!1,description:"The official Fundamentals tutorial for Redux: learn the standard patterns used in real-world Redux apps"},l={unversionedId:"tutorials/fundamentals/part-7-standard-patterns",id:"tutorials/fundamentals/part-7-standard-patterns",isDocsHomePage:!1,title:"Redux Fundamentals, Part 7: Standard Redux Patterns",description:"The official Fundamentals tutorial for Redux: learn the standard patterns used in real-world Redux apps",source:"@site/../docs/tutorials/fundamentals/part-7-standard-patterns.md",sourceDirName:"tutorials/fundamentals",slug:"/tutorials/fundamentals/part-7-standard-patterns",permalink:"/redux-in-chinese/tutorials/fundamentals/part-7-standard-patterns",version:"current",sidebar_label:"Standard Redux Patterns",frontMatter:{id:"part-7-standard-patterns",title:"Redux Fundamentals, Part 7: Standard Redux Patterns",sidebar_label:"Standard Redux Patterns",hide_title:!1,description:"The official Fundamentals tutorial for Redux: learn the standard patterns used in real-world Redux apps"},sidebar:"docs",previous:{title:"Redux Fundamentals, Part 6: Async Logic and Data Fetching",permalink:"/redux-in-chinese/tutorials/fundamentals/part-6-async-logic"},next:{title:"Redux Fundamentals, Part 8: Modern Redux with Redux Toolkit",permalink:"/redux-in-chinese/tutorials/fundamentals/part-8-modern-redux"}},d=[{value:"Action Creators",id:"action-creators",children:[{value:"Using Action Creators",id:"using-action-creators",children:[]}]},{value:"Memoized Selectors",id:"memoized-selectors",children:[{value:"Memoizing Selectors with <code>createSelector</code>",id:"memoizing-selectors-with-createselector",children:[]},{value:"Selectors with Multiple Arguments",id:"selectors-with-multiple-arguments",children:[]}]},{value:"Async Request Status",id:"async-request-status",children:[{value:"Loading State Enum Values",id:"loading-state-enum-values",children:[]}]},{value:"Flux Standard Actions",id:"flux-standard-actions",children:[]},{value:"Normalized State",id:"normalized-state",children:[]},{value:"Thunks and Promises",id:"thunks-and-promises",children:[]},{value:"\u4f60\u5b66\u5230\u4e86",id:"\u4f60\u5b66\u5230\u4e86",children:[]},{value:"\u4e0b\u4e00\u6b65",id:"\u4e0b\u4e00\u6b65",children:[]}],c={toc:d};function p(e){var t=e.components,r=(0,o.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,a.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"\u4f60\u5c06\u5b66\u5230")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},"Standard patterns used in real-world Redux apps, and why those patterns exist:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Action creators for encapsulating action objects"),(0,i.kt)("li",{parentName:"ul"},"Memoized selectors for improving performance"),(0,i.kt)("li",{parentName:"ul"},"Tracking request status via loading enums"),(0,i.kt)("li",{parentName:"ul"},"Normalizing state for managing collections of items"),(0,i.kt)("li",{parentName:"ul"},"Working with promises and thunks")))))),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"Prerequisites")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},"Understanding the topics in all previous sections")))),(0,i.kt)("p",null,"In ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/tutorials/fundamentals/part-6-async-logic"},"Part 6: Async Logic and Data Fetching"),', we saw how to use Redux middleware to write async logic that can talk to the store. In particular, we used the Redux "thunk" middleware to write functions that can contain reusable async logic, without knowing what Redux store they\'ll be talking to ahead of time.'),(0,i.kt)("p",null,"So far, we've covered the basics of how Redux actually works. However, real world Redux applications use some additional patterns on top of those basics."),(0,i.kt)("p",null,"It's important to note that ",(0,i.kt)("strong",{parentName:"p"},"none of these patterns are ",(0,i.kt)("em",{parentName:"strong"},"required")," to use Redux!")," But, there are very good reasons why each of these patterns exists, and you'll see some or all of them in almost every Redux codebase."),(0,i.kt)("p",null,"In this section, we'll rework our existing todo app code to use some of these patterns, and talk about why they're commonly used in Redux apps. Then, in ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/tutorials/fundamentals/part-8-modern-redux"},(0,i.kt)("strong",{parentName:"a"},"Part 8")),', we\'ll talk about "modern Redux", including ',(0,i.kt)("strong",{parentName:"p"},"how to use our official ",(0,i.kt)("a",{parentName:"strong",href:"https://redux-toolkit.js.org"},"Redux Toolkit"),' package to simplify all the Redux logic we\'ve written "by hand"')," in our app, and why ",(0,i.kt)("strong",{parentName:"p"},"we recommend using Redux Toolkit as the standard approach for writing Redux apps"),"."),(0,i.kt)("h2",{id:"action-creators"},"Action Creators"),(0,i.kt)("p",null,"In our app, we've been writing action objects directly in the code, where they're being dispatched:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"dispatch({ type: 'todos/todoAdded', payload: trimmedText })\n")),(0,i.kt)("p",null,'However, in practice, well-written Redux apps don\'t actually write those action objects inline when we dispatch them. Instead, we use "action creator" functions.'),(0,i.kt)("p",null,"An ",(0,i.kt)("strong",{parentName:"p"},"action creator")," is a function that creates and returns an action object. We typically use these so we don't have to write the action object by hand every time:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const todoAdded = text => {\n  return {\n    type: 'todos/todoAdded',\n    payload: text\n  }\n}\n")),(0,i.kt)("p",null,"We then use them by ",(0,i.kt)("strong",{parentName:"p"},"calling the action creator"),", and then ",(0,i.kt)("strong",{parentName:"p"},"passing the resulting action object directly to ",(0,i.kt)("inlineCode",{parentName:"strong"},"dispatch")),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"store.dispatch(todoAdded('Buy milk'))\n\nconsole.log(store.getState().todos)\n// [ {id: 0, text: 'Buy milk', completed: false}]\n")),(0,i.kt)(s.s,{title:"Detailed Explanation: Why use Action Creators?",mdxType:"DetailedExplanation"},(0,i.kt)("p",null,"In our small example todo app, writing action objects by hand every time isn't too difficult. In fact, by switching to using action creators, we've added ",(0,i.kt)("em",{parentName:"p"},"more")," work - now we have to write a function ",(0,i.kt)("em",{parentName:"p"},"and")," the action object."),(0,i.kt)("p",null,"But, what if we needed to dispatch the same action from many parts of the application? Or what if there's some additional logic that we have to do every time we dispatch an action, like creating a unique ID? We'd end up having to copy-paste the additional setup logic every time we need to dispatch that action."),(0,i.kt)("p",null,"Action creators have two primary purposes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"They prepare and format the contents of action objects"),(0,i.kt)("li",{parentName:"ul"},"They encapsulate any additional work needed whenever we create those actions")),(0,i.kt)("p",null,"That way, we have a consistent approach for creating actions, whether or not there's any extra work that needs to be done. The same goes for thunks as well.")),(0,i.kt)("h3",{id:"using-action-creators"},"Using Action Creators"),(0,i.kt)("p",null,"Let's update our todos slice file to use action creators for a couple of our action types."),(0,i.kt)("p",null,"We'll start with the two main actions we've been using so far: loading the list of todos from the server, and adding a new todo after saving it to the server."),(0,i.kt)("p",null,"Right now, ",(0,i.kt)("inlineCode",{parentName:"p"},"todosSlice.js")," is dispatching an action object directly, like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"dispatch({ type: 'todos/todosLoaded', payload: response.todos })\n")),(0,i.kt)("p",null,"We'll create a function that creates and returns that same kind of action object, but accepts the array of todos as its argument and puts it into the action as ",(0,i.kt)("inlineCode",{parentName:"p"},"action.payload"),". Then, we can dispatch the action using that new action creator inside of our ",(0,i.kt)("inlineCode",{parentName:"p"},"fetchTodos")," thunk:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},"// highlight-start\nexport const todosLoaded = todos => {\n  return {\n    type: 'todos/todosLoaded',\n    payload: todos\n  }\n}\n// highlight-end\n\nexport async function fetchTodos(dispatch, getState) {\n  const response = await client.get('/fakeApi/todos')\n  // highlight-next-line\n  dispatch(todosLoaded(response.todos))\n}\n")),(0,i.kt)("p",null,'We can also do the same thing for the "todo added" action:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},"// highlight-start\nexport const todoAdded = todo => {\n  return {\n    type: 'todos/todoAdded',\n    payload: todo\n  }\n}\n// highlight-end\n\nexport function saveNewTodo(text) {\n  return async function saveNewTodoThunk(dispatch, getState) {\n    const initialTodo = { text }\n    const response = await client.post('/fakeApi/todos', { todo: initialTodo })\n    // highlight-next-line\n    dispatch(todoAdded(response.todo))\n  }\n}\n")),(0,i.kt)("p",null,"While we're at it, let's do the same thing for the \"color filter changed\" action:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/filters/filtersSlice.js"',title:'"src/features/filters/filtersSlice.js"'},"// highlight-start\nexport const colorFilterChanged = (color, changeType) => {\n  return {\n    type: 'filters/colorFilterChanged',\n    payload: { color, changeType }\n  }\n}\n// highlight-end\n")),(0,i.kt)("p",null,"And since this action was being dispatched from the ",(0,i.kt)("inlineCode",{parentName:"p"},"<Footer>")," component, we'll need to import the ",(0,i.kt)("inlineCode",{parentName:"p"},"colorFilterChanged")," action creator over there and use it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/footer/Footer.js"',title:'"src/features/footer/Footer.js"'},"import React from 'react'\nimport { useSelector, useDispatch } from 'react-redux'\n\nimport { availableColors, capitalize } from '../filters/colors'\n// highlight-next-line\nimport { StatusFilters, colorFilterChanged } from '../filters/filtersSlice'\n\n// omit child components\n\nconst Footer = () => {\n  const dispatch = useDispatch()\n\n  const todosRemaining = useSelector(state => {\n    const uncompletedTodos = state.todos.filter(todo => !todo.completed)\n    return uncompletedTodos.length\n  })\n\n  const { status, colors } = useSelector(state => state.filters)\n\n  const onMarkCompletedClicked = () => dispatch({ type: 'todos/allCompleted' })\n  const onClearCompletedClicked = () =>\n    dispatch({ type: 'todos/completedCleared' })\n\n  // highlight-start\n  const onColorChange = (color, changeType) =>\n    dispatch(colorFilterChanged(color, changeType))\n  // highlight-end\n\n  const onStatusChange = status =>\n    dispatch({ type: 'filters/statusFilterChanged', payload: status })\n\n  // omit rendering output\n}\n\nexport default Footer\n")),(0,i.kt)("p",null,"Notice that the ",(0,i.kt)("inlineCode",{parentName:"p"},"colorFilterChanged")," action creator actually accepts two different arguments, and then combines them together to form the right ",(0,i.kt)("inlineCode",{parentName:"p"},"action.payload")," field."),(0,i.kt)("p",null,"This doesn't change anything about how the application works, or how the Redux data flow behaves - we're still creating action objects, and dispatching them. But, instead of writing action objects directly in our code all the time, we're now using action creators to prepare those action objects before they're dispatched."),(0,i.kt)("p",null,"We can also use action creators with thunk functions, and in fact ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/tutorials/fundamentals/part-6-async-logic#saving-todo-items"},"we wrapped a thunk in an action creator in the previous section")," . We specifically wrapped ",(0,i.kt)("inlineCode",{parentName:"p"},"saveNewTodo"),' in a "thunk action creator" function so that we could pass in a ',(0,i.kt)("inlineCode",{parentName:"p"},"text")," parameter. While ",(0,i.kt)("inlineCode",{parentName:"p"},"fetchTodos")," doesn't take any parameters, we could still wrap it in an action creator as well:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},"// highlight-next-line\nexport function fetchTodos() {\n  return async function fetchTodosThunk(dispatch, getState) {\n    const response = await client.get('/fakeApi/todos')\n    dispatch(todosLoaded(response.todos))\n  }\n}\n")),(0,i.kt)("p",null,"And that means we have to change the place it's dispatched in ",(0,i.kt)("inlineCode",{parentName:"p"},"index.js")," to call the outer thunk action creator function, and pass the returned inner thunk function to ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/index.js"',title:'"src/index.js"'},"import store from './store'\nimport { fetchTodos } from './features/todos/todosSlice'\n\n// highlight-next-line\nstore.dispatch(fetchTodos())\n")),(0,i.kt)("p",null,"We've written thunks using the ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," keyword so far to make it clear what they're doing. However, we can also write them using arrow function syntax instead. Using implicit returns can shorten the code, although it may make it a bit harder to read as well if you're not familiar with arrow functions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},"// Same thing as the above example!\n// highlight-next-line\nexport const fetchTodos = () => async dispatch => {\n  const response = await client.get('/fakeApi/todos')\n  dispatch(todosLoaded(response.todos))\n}\n")),(0,i.kt)("p",null,"Similarly, we ",(0,i.kt)("em",{parentName:"p"},"could")," shorten the plain action creators if we wanted to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},"// highlight-next-line\nexport const todoAdded = todo => ({ type: 'todos/todoAdded', payload: todo })\n")),(0,i.kt)("p",null,"It's up to you to decide whether using arrow functions this way is better or not."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"For more details on why action creators are useful, see:"),(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://blog.isquaredsoftware.com/2016/10/idiomatic-redux-why-use-action-creators/"},"Idiomatic Redux: Why Use Action Creators?"))))),(0,i.kt)("h2",{id:"memoized-selectors"},"Memoized Selectors"),(0,i.kt)("p",null,'We\'ve already seen that we can write "selector" functions, which accept the Redux ',(0,i.kt)("inlineCode",{parentName:"p"},"state")," object as an argument, and return a value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const selectTodos = state => state.todos\n")),(0,i.kt)("p",null,"What if we need to ",(0,i.kt)("em",{parentName:"p"},"derive")," some data? For example, maybe we want to have an array of only the todo IDs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const selectTodoIds = state => state.todos.map(todo => todo.id)\n")),(0,i.kt)("p",null,"However, ",(0,i.kt)("inlineCode",{parentName:"p"},"array.map()")," always returns a new array reference. We know that the React-Redux ",(0,i.kt)("inlineCode",{parentName:"p"},"useSelector")," hook will re-run its selector function after ",(0,i.kt)("em",{parentName:"p"},"every")," dispatched action, and if the selector result changes, it will force the component to re-render."),(0,i.kt)("p",null,"In this example, ",(0,i.kt)("strong",{parentName:"p"},"calling ",(0,i.kt)("inlineCode",{parentName:"strong"},"useSelector(selectTodoIds)")," will ",(0,i.kt)("em",{parentName:"strong"},"always")," cause the component to re-render after ",(0,i.kt)("em",{parentName:"strong"},"every")," action, because it's returning a new array reference!")),(0,i.kt)("p",null,"In Part 5, we saw that ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/tutorials/fundamentals/part-5-ui-react#selecting-data-in-list-items-by-id"},"we can pass ",(0,i.kt)("inlineCode",{parentName:"a"},"shallowEqual")," as an argument to ",(0,i.kt)("inlineCode",{parentName:"a"},"useSelector")),'. There\'s another option here, though: we could use "memoized" selectors.'),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Memoization")," is a kind of caching - specifically, saving the results of an expensive calculation, and reusing those results if we see the same inputs later."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Memoized selector functions")," are selectors that save the most recent result value, and if you call them multiple times with the same inputs, will return the same result value. If you call them with ",(0,i.kt)("em",{parentName:"p"},"different")," inputs than last time, they will recalculate a new result value, cache it, and return the new result."),(0,i.kt)("h3",{id:"memoizing-selectors-with-createselector"},"Memoizing Selectors with ",(0,i.kt)("inlineCode",{parentName:"h3"},"createSelector")),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://github.com/reduxjs/reselect"},"Reselect library")," provides a ",(0,i.kt)("inlineCode",{parentName:"strong"},"createSelector")," API that will generate memoized selector functions"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"createSelector"),' accepts one or more "input selector" functions as arguments, plus an "output selector", and returns the new selector function. Every time you call the selector:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'All "input selectors" are called with all of the arguments'),(0,i.kt)("li",{parentName:"ul"},'If any of the input selector return values have changed, the "output selector" will re-run'),(0,i.kt)("li",{parentName:"ul"},"All of the input selector results become arguments to the output selector"),(0,i.kt)("li",{parentName:"ul"},"The final result of the output selector is cached for next time")),(0,i.kt)("p",null,"Let's create a memoized version of ",(0,i.kt)("inlineCode",{parentName:"p"},"selectTodoIds")," and use that with our ",(0,i.kt)("inlineCode",{parentName:"p"},"<TodoList>"),"."),(0,i.kt)("p",null,"First, we need to install Reselect:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npm install reselect\n")),(0,i.kt)("p",null,"Then, we can import and call ",(0,i.kt)("inlineCode",{parentName:"p"},"createSelector"),". Our original ",(0,i.kt)("inlineCode",{parentName:"p"},"selectTodoIds")," function was defined over in ",(0,i.kt)("inlineCode",{parentName:"p"},"TodoList.js"),", but it's more common for selector functions to be written in the relevant slice file. So, let's add this to the todos slice:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},'// highlight-next-line\nimport { createSelector } from \'reselect\'\n\n// omit reducer\n\n// omit action creators\n\n// highlight-start\nexport const selectTodoIds = createSelector(\n  // First, pass one or more "input selector" functions:\n  state => state.todos,\n  // Then, an "output selector" that receives all the input results as arguments\n  // and returns a final result value\n  todos => todos.map(todo => todo.id)\n)\n// highlight-end\n')),(0,i.kt)("p",null,"Then, let's use it in ",(0,i.kt)("inlineCode",{parentName:"p"},"<TodoList>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/TodoList.js"',title:'"src/features/todos/TodoList.js"'},"import React from 'react'\nimport { useSelector, shallowEqual } from 'react-redux'\n\n// highlight-next-line\nimport { selectTodoIds } from './todosSlice'\nimport TodoListItem from './TodoListItem'\n\nconst TodoList = () => {\n  // highlight-next-line\n  const todoIds = useSelector(selectTodoIds)\n\n  const renderedListItems = todoIds.map(todoId => {\n    return <TodoListItem key={todoId} id={todoId} />\n  })\n\n  return <ul className=\"todo-list\">{renderedListItems}</ul>\n}\n")),(0,i.kt)("p",null,"This actually behaves a bit differently than the ",(0,i.kt)("inlineCode",{parentName:"p"},"shallowEqual")," comparison function does. Any time the ",(0,i.kt)("inlineCode",{parentName:"p"},"state.todos")," array changes, we're going to create a new todo IDs array as a result. That includes any immutable updates to todo items like toggling their ",(0,i.kt)("inlineCode",{parentName:"p"},"completed")," field, since we have to create a new array for the immutable update."),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Memoized selectors are only helpful when you actually derive additional values from the original data. If you are only looking up and returning an existing value, you can keep the selector as a plain function."))),(0,i.kt)("h3",{id:"selectors-with-multiple-arguments"},"Selectors with Multiple Arguments"),(0,i.kt)("p",null,"Our todo app is supposed to have the ability to filter the visible todos based on their completed status. Let's write a memoized selector that returns that filtered list of todos."),(0,i.kt)("p",null,"We know we need the entire ",(0,i.kt)("inlineCode",{parentName:"p"},"todos"),' array as one argument to our output selector. We also need to pass in the current completion status filter value as well. We\'ll add a separate "input selector" to extract each value, and pass the results to the "output selector".'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},"import { createSelector } from 'reselect'\nimport { StatusFilters } from '../filters/filtersSlice'\n\n// omit other code\n\n// highlight-start\nexport const selectFilteredTodos = createSelector(\n  // First input selector: all todos\n  state => state.todos,\n  // Second input selector: current status filter\n  state => state.filters.status,\n  // Output selector: receives both values\n  (todos, status) => {\n    if (status === StatusFilters.All) {\n      return todos\n    }\n\n    const completedStatus = status === StatusFilters.Completed\n    // Return either active or completed todos based on filter\n    return todos.filter(todo => todo.completed === completedStatus)\n  }\n)\n// highlight-end\n")),(0,i.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Note that we've now added an import dependency between two slices - the ",(0,i.kt)("inlineCode",{parentName:"p"},"todosSlice")," is importing a value from the ",(0,i.kt)("inlineCode",{parentName:"p"},"filtersSlice"),". This is legal, but be careful. ",(0,i.kt)("strong",{parentName:"p"},"If two slices ",(0,i.kt)("em",{parentName:"strong"},"both"),' try to import something from each other, you can end up with a "cyclic import dependency" problem that can cause your code to crash'),". If that happens, try moving some common code to its own file and import from that file instead."))),(0,i.kt)("p",null,'Now we can use this new "filtered todos" selector as an input to another selector that returns the IDs of those todos:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},"export const selectFilteredTodoIds = createSelector(\n  // Pass our other memoized selector as an input\n  selectFilteredTodos,\n  // And derive data in the output selector\n  filteredTodos => filteredTodos.map(todo => todo.id)\n)\n")),(0,i.kt)("p",null,"If we switch ",(0,i.kt)("inlineCode",{parentName:"p"},"<TodoList>")," to use ",(0,i.kt)("inlineCode",{parentName:"p"},"selectFilteredTodoIds"),", we should then be able to mark a couple todo items as completed:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Todo app - todos marked completed",src:n(5155).Z})),(0,i.kt)("p",null,"and then filter the list to ",(0,i.kt)("em",{parentName:"p"},"only")," show completed todos:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Todo app - todos marked completed",src:n(355).Z})),(0,i.kt)("p",null,"We can then expand our ",(0,i.kt)("inlineCode",{parentName:"p"},"selectFilteredTodos")," to also include color filtering in the selection as well:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},"export const selectFilteredTodos = createSelector(\n  // First input selector: all todos\n  selectTodos,\n  // Second input selector: all filter values\n  // highlight-next-line\n  state => state.filters,\n  // Output selector: receives both values\n  (todos, filters) => {\n    // highlight-start\n    const { status, colors } = filters\n    const showAllCompletions = status === StatusFilters.All\n    if (showAllCompletions && colors.length === 0) {\n      // highlight-end\n      return todos\n    }\n\n    // highlight-next-line\n    const completedStatus = status === StatusFilters.Completed\n    // Return either active or completed todos based on filter\n    return todos.filter(todo => {\n      // highlight-start\n      const statusMatches =\n        showAllCompletions || todo.completed === completedStatus\n      const colorMatches = colors.length === 0 || colors.includes(todo.color)\n      return statusMatches && colorMatches\n      // highlight-end\n    })\n  }\n)\n")),(0,i.kt)("p",null,"Notice that by encapsulating the logic in this selector, our component never needed to change, even as we changed the filtering behavior. Now we can filter by both status and color at once:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Todo app - status and color filters",src:n(9941).Z})),(0,i.kt)("p",null,"Finally, we've got several places where our code is looking up ",(0,i.kt)("inlineCode",{parentName:"p"},"state.todos"),". We're going to be making some changes to how that state is designed as we go through the rest of this section, so we'll extract a single ",(0,i.kt)("inlineCode",{parentName:"p"},"selectTodos")," selector and use that everywhere. We can also move ",(0,i.kt)("inlineCode",{parentName:"p"},"selectTodoById")," over into the ",(0,i.kt)("inlineCode",{parentName:"p"},"todosSlice"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},"export const selectTodos = state => state.todos\n\nexport const selectTodoById = (state, todoId) => {\n  return selectTodos(state).find(todo => todo.id === todoId)\n}\n")),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"To learn more about how to use Reselect and memoized selectors, see:"),(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/reduxjs/reselect"},"Reselect docs")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://blog.isquaredsoftware.com/2017/12/idiomatic-redux-using-reselect-selectors/"},"Idiomatic Redux: Using Reselect Selectors for Encapsulation and Performance"))))),(0,i.kt)("h2",{id:"async-request-status"},"Async Request Status"),(0,i.kt)("p",null,"We're using an async thunk to fetch the initial list of todos from the server. Since we're using a fake server API, that response comes back immediately. In a real app, the API call might take a while to resolve. In that case, it's common to show some kind of a loading spinner while we wait for the response to complete."),(0,i.kt)("p",null,"This is usually handled in Redux apps by:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Having some kind of "loading state" value to indicate the current status of a request'),(0,i.kt)("li",{parentName:"ul"},'Dispatching a "request started" action ',(0,i.kt)("em",{parentName:"li"},"before")," making the API call, which is handled by changing the loading state value"),(0,i.kt)("li",{parentName:"ul"},"Updating the loading state value again when the request completes to indicate that the call is done")),(0,i.kt)("p",null,"The UI layer then shows a loading spinner while the request is in progress, and switches to showing the actual data when the request is complete."),(0,i.kt)("p",null,"We're going to update our todos slice to track a loading state value, and dispatch an additional ",(0,i.kt)("inlineCode",{parentName:"p"},"'todos/todosLoading'")," action as part of the ",(0,i.kt)("inlineCode",{parentName:"p"},"fetchTodos")," thunk."),(0,i.kt)("p",null,"Right now, the ",(0,i.kt)("inlineCode",{parentName:"p"},"state")," of our todos reducer is only the array of todos itself. If we want to track the loading state inside the todos slice, we'll need to reorganize the todos state to be an object that has the todos array ",(0,i.kt)("em",{parentName:"p"},"and")," the loading state value. That also means rewriting the reducer logic to handle the additional nesting:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},"// highlight-start\nconst initialState = {\n  status: 'idle',\n  entities: []\n}\n// highlight-end\n\nexport default function todosReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'todos/todoAdded': {\n      // highlight-start\n      return {\n        ...state,\n        entities: [...state.entities, action.payload]\n      }\n      // highlight-end\n    }\n    case 'todos/todoToggled': {\n      // highlight-start\n      return {\n        ...state,\n        entities: state.entities.map(todo => {\n          if (todo.id !== action.payload) {\n            return todo\n          }\n\n          return {\n            ...todo,\n            completed: !todo.completed\n          }\n        })\n      }\n      // highlight-end\n    }\n    // omit other cases\n    default:\n      return state\n  }\n}\n\n// omit action creators\n\n// highlight-next-line\nexport const selectTodos = state => state.todos.entities\n")),(0,i.kt)("p",null,"There's a few important things to note here:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The todos array is now nested as ",(0,i.kt)("inlineCode",{parentName:"li"},"state.entities")," in the ",(0,i.kt)("inlineCode",{parentName:"li"},"todosReducer"),' state object. The word "entities" is a term that means "unique items with an ID", which does describe our todo objects.'),(0,i.kt)("li",{parentName:"ul"},"That also means the array is nested in the ",(0,i.kt)("em",{parentName:"li"},"entire")," Redux state object as ",(0,i.kt)("inlineCode",{parentName:"li"},"state.todos.entities")),(0,i.kt)("li",{parentName:"ul"},"We now have to do extra steps in the reducer to copy the additional level of nesting for correct immutable updates, such as ",(0,i.kt)("inlineCode",{parentName:"li"},"state")," object -> ",(0,i.kt)("inlineCode",{parentName:"li"},"entities")," array -> ",(0,i.kt)("inlineCode",{parentName:"li"},"todo")," object"),(0,i.kt)("li",{parentName:"ul"},"Because the rest of our code is ",(0,i.kt)("em",{parentName:"li"},"only")," accessing the todos state via selectors, ",(0,i.kt)("strong",{parentName:"li"},"we only need to update the ",(0,i.kt)("inlineCode",{parentName:"strong"},"selectTodos")," selector")," - the rest of the UI will continue to work as expected even though we reshaped our state considerably.")),(0,i.kt)("h3",{id:"loading-state-enum-values"},"Loading State Enum Values"),(0,i.kt)("p",null,"You'll also notice that we've defined the loading state field as a string enum:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  status: 'idle' // or: 'loading', 'succeeded', 'failed'\n}\n")),(0,i.kt)("p",null,"instead of an ",(0,i.kt)("inlineCode",{parentName:"p"},"isLoading")," boolean."),(0,i.kt)("p",null,'A boolean limits us to two possibilities: "loading" or "not loading". In reality, ',(0,i.kt)("strong",{parentName:"p"},"it's possible for a request to actually be in ",(0,i.kt)("em",{parentName:"strong"},"many")," different states"),", such as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Hasn't started at all"),(0,i.kt)("li",{parentName:"ul"},"In progress"),(0,i.kt)("li",{parentName:"ul"},"Succeeded"),(0,i.kt)("li",{parentName:"ul"},"Failed"),(0,i.kt)("li",{parentName:"ul"},"Succeeded, but now back in a situation where we might want to refetch")),(0,i.kt)("p",null,"It's also possible that the app logic should only transition between specific states based on certain actions, and this is harder to implement using booleans."),(0,i.kt)("p",null,"Because of this, we recommend ",(0,i.kt)("strong",{parentName:"p"},"storing loading state as a string enum value instead of boolean flags"),"."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"For a detailed explanation of why loading states should be enums, see:"),(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/redux-in-chinese/style-guide/style-guide#treat-reducers-as-state-machines"},"Redux Style Guide: treat reducers as state machines"))))),(0,i.kt)("p",null,'Based on that, we\'ll add a new "loading" action that will set our status to ',(0,i.kt)("inlineCode",{parentName:"p"},"'loading'"),', and update the "loaded" action to reset the state flag to ',(0,i.kt)("inlineCode",{parentName:"p"},"'idle'"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',title:'"src/features/todos/todosSlice.js"'},"const initialState = {\n  status: 'idle',\n  entities: []\n}\n\nexport default function todosReducer(state = initialState, action) {\n  switch (action.type) {\n    // omit other cases\n    // highlight-start\n    case 'todos/todosLoading': {\n      return {\n        ...state,\n        status: 'loading'\n      }\n    }\n    // highlight-end\n    case 'todos/todosLoaded': {\n      return {\n        ...state,\n        // highlight-next-line\n        status: 'idle',\n        entities: action.payload\n      }\n    }\n    default:\n      return state\n  }\n}\n\n// omit action creators\n\n// Thunk function\nexport const fetchTodos = () => async dispatch => {\n  // highlight-next-line\n  dispatch(todosLoading())\n  const response = await client.get('/fakeApi/todos')\n  dispatch(todosLoaded(response.todos))\n}\n")),(0,i.kt)("p",null,"However, before we try to show this in the UI, we need to modify the fake server API to add an artificial delay to our API calls. Open up ",(0,i.kt)("inlineCode",{parentName:"p"},"src/api/server.js"),", and look for this commented-out line around line 63:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/api/server.js"',title:'"src/api/server.js"'},"new Server({\n  routes() {\n    this.namespace = 'fakeApi'\n    // highlight-next-line\n    // this.timing = 2000\n\n    // omit other code\n  }\n})\n")),(0,i.kt)("p",null,"If you uncomment that line, the fake server will add a 2-second delay to every API call our app makes, which gives us enough time to actually see a loading spinner being displayed."),(0,i.kt)("p",null,"Now, we can read the loading state value in our ",(0,i.kt)("inlineCode",{parentName:"p"},"<TodoList>")," component, and show a loading spinner instead based on that value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/TodoList.js"',title:'"src/features/todos/TodoList.js"'},'// omit imports\n\nconst TodoList = () => {\n  const todoIds = useSelector(selectFilteredTodoIds)\n  // highlight-start\n  const loadingStatus = useSelector(state => state.todos.status)\n\n  if (loadingStatus === \'loading\') {\n    return (\n      <div className="todo-list">\n        <div className="loader" />\n      </div>\n    )\n  }\n  // highlight-end\n\n  const renderedListItems = todoIds.map(todoId => {\n    return <TodoListItem key={todoId} id={todoId} />\n  })\n\n  return <ul className="todo-list">{renderedListItems}</ul>\n}\n')),(0,i.kt)("p",null,"In a real app, we'd also want to handle API failure errors and other potential cases."),(0,i.kt)("p",null,"Here's what the app looks like with that loading status enabled (to see the spinner again, reload the app preview or open it in a new tab):"),(0,i.kt)("iframe",{class:"codesandbox",src:"https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-7-asyncLoading/?fontsize=14&hidenavigation=1&theme=dark&runonclick=1",title:"redux-fundamentals-example-app",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),(0,i.kt)("h2",{id:"flux-standard-actions"},"Flux Standard Actions"),(0,i.kt)("p",null,"The Redux store itself does not actually care what fields you put into your action object. It only cares that ",(0,i.kt)("inlineCode",{parentName:"p"},"action.type")," exists and has a value, and normal Redux actions always use a string for ",(0,i.kt)("inlineCode",{parentName:"p"},"action.type"),". That means that you ",(0,i.kt)("em",{parentName:"p"},"could")," put any other fields into the action that you want. Maybe we could have ",(0,i.kt)("inlineCode",{parentName:"p"},"action.todo"),' for a "todo added" action, or ',(0,i.kt)("inlineCode",{parentName:"p"},"action.color"),", and so on."),(0,i.kt)("p",null,"However, if every action uses different field names for its data fields, it can be hard to know ahead of time what fields you need to handle in each reducer."),(0,i.kt)("p",null,"That's why the Redux community came up with ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/redux-utilities/flux-standard-action#motivation"},'the "Flux Standard Actions" convention'),', or "FSA". This is a suggested approach for how to organize fields inside of action objects, so that developers always know what fields contain what kind of data. The FSA pattern is widely used in the Redux community, and in fact you\'ve already been using it throughout this whole tutorial.'),(0,i.kt)("p",null,"The FSA convention says that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'If your action object has any actual data, that "data" value of your action should always go in ',(0,i.kt)("inlineCode",{parentName:"li"},"action.payload")),(0,i.kt)("li",{parentName:"ul"},"An action may also have an ",(0,i.kt)("inlineCode",{parentName:"li"},"action.meta")," field with extra descriptive data"),(0,i.kt)("li",{parentName:"ul"},"An action may have an ",(0,i.kt)("inlineCode",{parentName:"li"},"action.error")," field with error information")),(0,i.kt)("p",null,"So, ",(0,i.kt)("em",{parentName:"p"},"all")," Redux actions MUST:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"be a plain JavaScript object"),(0,i.kt)("li",{parentName:"ul"},"have a ",(0,i.kt)("inlineCode",{parentName:"li"},"type")," field")),(0,i.kt)("p",null,"And if you write your actions using the FSA pattern, an action MAY"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"have a ",(0,i.kt)("inlineCode",{parentName:"li"},"payload")," field"),(0,i.kt)("li",{parentName:"ul"},"have an ",(0,i.kt)("inlineCode",{parentName:"li"},"error")," field"),(0,i.kt)("li",{parentName:"ul"},"have a ",(0,i.kt)("inlineCode",{parentName:"li"},"meta")," field")),(0,i.kt)(s.s,{title:"Detailed Explanation: FSAs and Errors",mdxType:"DetailedExplanation"},(0,i.kt)("p",null,"The FSA specification says that:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The optional ",(0,i.kt)("inlineCode",{parentName:"p"},"error")," property MAY be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the action represents an error.\nAn action whose ",(0,i.kt)("inlineCode",{parentName:"p"},"error")," is true is analogous to a rejected Promise. By convention, the ",(0,i.kt)("inlineCode",{parentName:"p"},"payload")," SHOULD be an error object.\nIf ",(0,i.kt)("inlineCode",{parentName:"p"},"error")," has any other value besides ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", including ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", the action MUST NOT be interpreted as an error.")),(0,i.kt)("p",null,'The FSA specs also argue against having specific action types for things like "loading succeeded" and "loading failed".'),(0,i.kt)("p",null,"However, in practice, the Redux community has ignored the idea of using ",(0,i.kt)("inlineCode",{parentName:"p"},"action.error")," as a boolean flag, and instead settled on separate action types, like ",(0,i.kt)("inlineCode",{parentName:"p"},"'todos/todosLoadingSucceeded'")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"'todos/todosLoadingFailed'"),". This is because it's much easier to check for those action types than it is to first handle ",(0,i.kt)("inlineCode",{parentName:"p"},"'todos/todosLoaded'")," and ",(0,i.kt)("em",{parentName:"p"},"then")," check ",(0,i.kt)("inlineCode",{parentName:"p"},"if (action.error)"),"."),(0,i.kt)("p",null,"You can do whichever approach works better for you, but most apps use separate action types for success and failure.")),(0,i.kt)("h2",{id:"normalized-state"},"Normalized State"),(0,i.kt)("p",null,"So far, we've kept our todos in an array. This is reasonable, because we received the data from the server as an array, and we also need to loop over the todos to show them as a list in the UI."),(0,i.kt)("p",null,"However, in larger Redux apps, it is common to store data in a ",(0,i.kt)("strong",{parentName:"p"},"normalized state structure"),'. "Normalization" means:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Making sure there is only one copy of each piece of data"),(0,i.kt)("li",{parentName:"ul"},"Storing items in a way that allows directly finding items by ID"),(0,i.kt)("li",{parentName:"ul"},"Referring to other items based on IDs, instead of copying the entire item")),(0,i.kt)("p",null,"For example, in a blogging application, you might have ",(0,i.kt)("inlineCode",{parentName:"p"},"Post")," objects that point to ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Comment")," objects. There might be many posts by the same person, so if every ",(0,i.kt)("inlineCode",{parentName:"p"},"Post")," object includes an entire ",(0,i.kt)("inlineCode",{parentName:"p"},"User"),", we would have many copies of the same ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," object. Instead, a ",(0,i.kt)("inlineCode",{parentName:"p"},"Post")," object would have a user ID value as ",(0,i.kt)("inlineCode",{parentName:"p"},"post.user"),", and then we could look up ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," objects by ID as ",(0,i.kt)("inlineCode",{parentName:"p"},"state.users[post.user]"),"."),(0,i.kt)("p",null,"This means we typically organize our data as objects instead of arrays, where the item IDs are the keys and the items themselves are the values, like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const rootState = {\n  todos: {\n    status: 'idle',\n    // highlight-start\n    entities: {\n      2: { id: 2, text: 'Buy milk', completed: false },\n      7: { id: 7, text: 'Clean room', completed: true }\n    }\n    // highlight-end\n  }\n}\n")),(0,i.kt)("p",null,"Let's convert our todos slice to store the todos in a normalized form. This will require some significant changes to our reducer logic, as well as updating the selectors:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/todos/todosSlice"',title:'"src/features/todos/todosSlice"'},"const initialState = {\n  status: 'idle',\n  // highlight-next-line\n  entities: {}\n}\n\nexport default function todosReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'todos/todoAdded': {\n      const todo = action.payload\n      // highlight-start\n      return {\n        ...state,\n        entities: {\n          ...state.entities,\n          [todo.id]: todo\n        }\n      }\n      // highlight-end\n    }\n    case 'todos/todoToggled': {\n      // highlight-start\n      const todoId = action.payload\n      const todo = state.entities[todoId]\n      return {\n        ...state,\n        entities: {\n          ...state.entities,\n          [todoId]: {\n            ...todo,\n            completed: !todo.completed\n          }\n        }\n      }\n      // highlight-end\n    }\n    case 'todos/colorSelected': {\n      // highlight-start\n      const { color, todoId } = action.payload\n      const todo = state.entities[todoId]\n      return {\n        ...state,\n        entities: {\n          ...state.entities,\n          [todoId]: {\n            ...todo,\n            color\n          }\n        }\n      }\n      // highlight-end\n    }\n    case 'todos/todoDeleted': {\n      // highlight-start\n      const newEntities = { ...state.entities }\n      delete newEntities[action.payload]\n      return {\n        ...state,\n        entities: newEntities\n      }\n      // highlight-end\n    }\n    case 'todos/allCompleted': {\n      // highlight-start\n      const newEntities = { ...state.entities }\n      Object.values(newEntities).forEach(todo => {\n        newEntities[todo.id] = {\n          ...todo,\n          completed: true\n        }\n      })\n      return {\n        ...state,\n        entities: newEntities\n      }\n      // highlight-end\n    }\n    case 'todos/completedCleared': {\n      // highlight-start\n      const newEntities = { ...state.entities }\n      Object.values(newEntities).forEach(todo => {\n        if (todo.completed) {\n          delete newEntities[todo.id]\n        }\n      })\n      return {\n        ...state,\n        entities: newEntities\n      }\n      // highlight-end\n    }\n    case 'todos/todosLoading': {\n      return {\n        ...state,\n        status: 'loading'\n      }\n    }\n    case 'todos/todosLoaded': {\n      // highlight-start\n      const newEntities = {}\n      action.payload.forEach(todo => {\n        newEntities[todo.id] = todo\n      })\n      return {\n        ...state,\n        status: 'idle',\n        entities: newEntities\n      }\n      // highlight-end\n    }\n    default:\n      return state\n  }\n}\n\n// omit action creators\n\n// highlight-start\nconst selectTodoEntities = state => state.todos.entities\n\nexport const selectTodos = createSelector(selectTodoEntities, entities =>\n  Object.values(entities)\n)\n\nexport const selectTodoById = (state, todoId) => {\n  return selectTodoEntities(state)[todoId]\n}\n// highlight-end\n")),(0,i.kt)("p",null,"Because our ",(0,i.kt)("inlineCode",{parentName:"p"},"state.entities")," field is now an object instead of an array, we have to use nested object spread operators to update the data instead of array operations. Also, we can't loop over objects the way we loop over arrays, so there's several places where we have to use ",(0,i.kt)("inlineCode",{parentName:"p"},"Object.values(entities)")," to get an array of the todo items so that we can loop over them."),(0,i.kt)("p",null,"The good news is that because we're using selectors to encapsulate the state lookups, our UI still doesn't have to change. The bad news is that the reducer code is actually longer and more complicated."),(0,i.kt)("p",null,"Part of the issue here is that ",(0,i.kt)("strong",{parentName:"p"},"this todo app example is not a large real-world application"),". So, normalizing state is not as useful in this particular app, and it's harder to see the potential benefits."),(0,i.kt)("p",null,"Fortunately, in ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/tutorials/fundamentals/part-8-modern-redux"},"Part 8: Modern Redux with Redux Toolkit")," we'll see some ways to drastically shorten the reducer logic for managing our normalized state."),(0,i.kt)("p",null,"For now, the important things to understand are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Normalization ",(0,i.kt)("em",{parentName:"li"},"is")," commonly used in Redux apps"),(0,i.kt)("li",{parentName:"ul"},"The primary benefits are being able to look up individual items by ID and ensure that only one copy of an item exists in the state")),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"For more details on why normalization is useful with Redux, see:"),(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/redux-in-chinese/recipes/structuring-reducers/normalizing-state-shape"},"Structuring Reducers: Normalizing State Shape"))))),(0,i.kt)("h2",{id:"thunks-and-promises"},"Thunks and Promises"),(0,i.kt)("p",null,"We have one last pattern to look at for this section. We've already seen how to handle loading state in the Redux store based on dispatched actions. What if we need to look at the results of a thunk in our components?"),(0,i.kt)("p",null,"Whenever you call ",(0,i.kt)("inlineCode",{parentName:"p"},"store.dispatch(action)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch")," will actually return the ",(0,i.kt)("inlineCode",{parentName:"p"},"action")," as its result. Middleware can then modify that behavior and return some other value instead."),(0,i.kt)("p",null,"We've already seen that the Redux Thunk middleware lets us pass a function to ",(0,i.kt)("inlineCode",{parentName:"p"},"dispatch"),", calls the function, and then returns the result:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="reduxThunkMiddleware.js"',title:'"reduxThunkMiddleware.js"'},"const reduxThunkMiddleware = storeAPI => next => action => {\n  // If the \"action\" is actually a function instead...\n  if (typeof action === 'function') {\n    // then call the function and pass `dispatch` and `getState` as arguments\n    // Also, return whatever the thunk function returns\n    return action(storeAPI.dispatch, storeAPI.getState)\n  }\n\n  // Otherwise, it's a normal action - send it onwards\n  return next(action)\n}\n")),(0,i.kt)("p",null,"This means that ",(0,i.kt)("strong",{parentName:"p"},"we can write thunk functions that return a promise, and wait on that promise in our components"),"."),(0,i.kt)("p",null,"We already have our ",(0,i.kt)("inlineCode",{parentName:"p"},"<Header>")," component dispatching a thunk to save new todo entries to the server. Let's add some loading state inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"<Header>")," component, then disable the text input and show another loading spinner while we're waiting for the server:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/features/header/Header.js"',title:'"src/features/header/Header.js"'},"const Header = () => {\n  const [text, setText] = useState('')\n  // highlight-next-line\n  const [status, setStatus] = useState('idle')\n  const dispatch = useDispatch()\n\n  const handleChange = e => setText(e.target.value)\n\n  // highlight-start\n  const handleKeyDown = async e => {\n    // If the user pressed the Enter key:\n    const trimmedText = text.trim()\n    if (e.which === 13 && trimmedText) {\n      // Create and dispatch the thunk function itself\n      setStatus('loading')\n      // Wait for the promise returned by saveNewTodo\n      await dispatch(saveNewTodo(trimmedText))\n      // And clear out the text input\n      setText('')\n      setStatus('idle')\n    }\n  }\n\n  let isLoading = status === 'loading'\n  let placeholder = isLoading ? '' : 'What needs to be done?'\n  let loader = isLoading ? <div className=\"loader\" /> : null\n  // highlight-end\n\n  return (\n    <header className=\"header\">\n      <input\n        className=\"new-todo\"\n        placeholder={placeholder}\n        autoFocus={true}\n        value={text}\n        onChange={handleChange}\n        onKeyDown={handleKeyDown}\n        // highlight-next-line\n        disabled={isLoading}\n      />\n      // highlight-next-line\n      {loader}\n    </header>\n  )\n}\n\nexport default Header\n")),(0,i.kt)("p",null,"Now, if we add a todo, we'll see a spinner in the header:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Todo app - component loading spinner",src:n(6944).Z})),(0,i.kt)("h2",{id:"\u4f60\u5b66\u5230\u4e86"},"\u4f60\u5b66\u5230\u4e86"),(0,i.kt)("p",null,"As you've seen, there's several additional patterns that are widely used in Redux apps. These patterns are not required, and may involve writing more code initially, but they provide benefits like making logic reusable, encapsulating implementation details, improving app performance, and making it easier to look up data."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"For more details on why these patterns exist and how Redux is meant to be used, see:"),(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/"},"Idiomatic Redux: The Tao of Redux, Part 1 - Implementation and Intent")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/"},"Idiomatic Redux: The Tao of Redux, Part 2 - Practice and Philosophy"))))),(0,i.kt)("p",null,"Here's how our app looks after it's been fully converted to use these patterns:"),(0,i.kt)("iframe",{class:"codesandbox",src:"https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-8-normalizedState/?fontsize=14&hidenavigation=1&theme=dark&runonclick=1",title:"redux-fundamentals-example-app",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"\u603b\u7ed3")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Action creator functions encapsulate preparing action objects and thunks"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Action creators can accept arguments and contain setup logic, and return the final action object or thunk function"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Memoized selectors help improve Redux app performance"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Reselect has a ",(0,i.kt)("inlineCode",{parentName:"li"},"createSelector")," API that generates memoized selectors"),(0,i.kt)("li",{parentName:"ul"},"Memoized selectors return the same result reference if given the same inputs"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Request status should be stored as an enum, not booleans"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Using enums like ",(0,i.kt)("inlineCode",{parentName:"li"},"'idle'")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"'loading'")," helps track status consistently"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},'"Flux Standard Actions" are the common convention for organizing action objects'),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Actions use ",(0,i.kt)("inlineCode",{parentName:"li"},"payload")," for data, ",(0,i.kt)("inlineCode",{parentName:"li"},"meta")," for extra descriptions, and ",(0,i.kt)("inlineCode",{parentName:"li"},"error")," for errors"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Normalized state makes it easier to find items by ID"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Normalized data is stored in objects instead of arrays, with item IDs as keys"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Thunks can return promises from ",(0,i.kt)("inlineCode",{parentName:"strong"},"dispatch")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Components can wait for async thunks to complete, then do more work")))))),(0,i.kt)("h2",{id:"\u4e0b\u4e00\u6b65"},"\u4e0b\u4e00\u6b65"),(0,i.kt)("p",null,'Writing all this code "by hand" can be time-consuming and difficult. ',(0,i.kt)("strong",{parentName:"p"},"That's why we recommend that you use our official ",(0,i.kt)("a",{parentName:"strong",href:"https://redux-toolkit.js.org"},"Redux Toolkit")," package to write your Redux logic instead"),"."),(0,i.kt)("p",null,"Redux Toolkit includes APIs that ",(0,i.kt)("strong",{parentName:"p"},"help you write all the typical Redux usage patterns, but with less code"),". It also helps ",(0,i.kt)("strong",{parentName:"p"},"prevent common mistakes")," like accidentally mutating state."),(0,i.kt)("p",null,"In ",(0,i.kt)("a",{parentName:"p",href:"/redux-in-chinese/tutorials/fundamentals/part-8-modern-redux"},"Part 8: Modern Redux"),", we'll cover how to use Redux Toolkit to simplify all the code we've written so far."))}p.isMDXComponent=!0},6944:function(e,t,n){"use strict";t.Z=n.p+"assets/images/todos-app-headerLoading-9b4bca9cb4675bf35df09a2e709ecccb.png"},5155:function(e,t,n){"use strict";t.Z=n.p+"assets/images/todos-app-markedCompleted-fe1ddaba1c85e3f9841728d39459d126.png"},9941:function(e,t,n){"use strict";t.Z=n.p+"assets/images/todos-app-selectorFilters-9ebfc37b389c997e011aff74d525a1aa.png"},355:function(e,t,n){"use strict";t.Z=n.p+"assets/images/todos-app-showCompleted-6eeff512e106457fd4fb469d2f66337d.png"}}]);