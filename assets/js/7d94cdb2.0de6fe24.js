(self.webpackChunk=self.webpackChunk||[]).push([[942],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return u},kt:function(){return h}});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),d=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},u=function(e){var n=d(e.components);return r.createElement(s.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=d(t),h=i,m=p["".concat(s,".").concat(h)]||p[h]||l[h]||a;return t?r.createElement(m,c(c({ref:n},u),{},{components:t})):r.createElement(m,c({ref:n},u))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,c=new Array(a);c[0]=p;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,c[1]=o;for(var d=2;d<a;d++)c[d]=t[d];return r.createElement.apply(null,c)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},6196:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return c},metadata:function(){return o},toc:function(){return s},default:function(){return u}});var r=t(2122),i=t(9756),a=(t(7294),t(3905)),c={id:"code-splitting",title:"Code Splitting",hide_title:!1},o={unversionedId:"recipes/code-splitting",id:"recipes/code-splitting",isDocsHomePage:!1,title:"Code Splitting",description:"In large web applications, it is often desirable to split up the app code into multiple JS bundles that can be loaded on-demand. This strategy, called 'code splitting', helps to increase performance of your application by reducing the size of the initial JS payload that must be fetched.",source:"@site/../docs/recipes/CodeSplitting.md",sourceDirName:"recipes",slug:"/recipes/code-splitting",permalink:"/redux-in-chinese/recipes/code-splitting",version:"current",frontMatter:{id:"code-splitting",title:"Code Splitting",hide_title:!1},sidebar:"docs",previous:{title:"Isolating Redux Sub-Apps",permalink:"/redux-in-chinese/recipes/isolating-redux-sub-apps"},next:{title:"Troubleshooting",permalink:"/redux-in-chinese/recipes/troubleshooting"}},s=[{value:"Basic Principle",id:"basic-principle",children:[{value:"Using <code>replaceReducer</code>",id:"using-replacereducer",children:[]}]},{value:"Reducer Injection Approaches",id:"reducer-injection-approaches",children:[{value:"Defining an <code>injectReducer</code> function",id:"defining-an-injectreducer-function",children:[]},{value:"Using a &#39;Reducer Manager&#39;",id:"using-a-reducer-manager",children:[]}]},{value:"Libraries and Frameworks",id:"libraries-and-frameworks",children:[]}],d={toc:s};function u(e){var n=e.components,t=(0,i.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In large web applications, it is often desirable to split up the app code into multiple JS bundles that can be loaded on-demand. This strategy, called 'code splitting', helps to increase performance of your application by reducing the size of the initial JS payload that must be fetched."),(0,a.kt)("p",null,"To code split with Redux, we want to be able to dynamically add reducers to the store. However, Redux really only has a single root reducer function. This root reducer is normally generated by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"combineReducers()")," or a similar function when the application is initialized. In order to dynamically add more reducers, we need to call that function again to re-generate the root reducer. Below, we discuss some approaches to solving this problem and reference two libraries that provide this functionality."),(0,a.kt)("h2",{id:"basic-principle"},"Basic Principle"),(0,a.kt)("h3",{id:"using-replacereducer"},"Using ",(0,a.kt)("inlineCode",{parentName:"h3"},"replaceReducer")),(0,a.kt)("p",null,"The Redux store exposes a ",(0,a.kt)("inlineCode",{parentName:"p"},"replaceReducer")," function, which replaces the current active root reducer function with a new root reducer function. Calling it will swap the internal reducer function reference, and dispatch an action to help any newly-added slice reducers initialize themselves:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const newRootReducer = combineReducers({\n  existingSlice: existingSliceReducer,\n  newSlice: newSliceReducer\n})\n\nstore.replaceReducer(newRootReducer)\n")),(0,a.kt)("h2",{id:"reducer-injection-approaches"},"Reducer Injection Approaches"),(0,a.kt)("h3",{id:"defining-an-injectreducer-function"},"Defining an ",(0,a.kt)("inlineCode",{parentName:"h3"},"injectReducer")," function"),(0,a.kt)("p",null,"We will likely want to call ",(0,a.kt)("inlineCode",{parentName:"p"},"store.replaceReducer()")," from anywhere in the application. Because of that, it's helpful\nto define a reusable ",(0,a.kt)("inlineCode",{parentName:"p"},"injectReducer()")," function that keeps references to all of the existing slice reducers, and attach\nthat to the store instance."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import { createStore } from 'redux'\n\n// Define the Reducers that will always be present in the application\nconst staticReducers = {\n  users: usersReducer,\n  posts: postsReducer\n}\n\n// Configure the store\nexport default function configureStore(initialState) {\n  const store = createStore(createReducer(), initialState)\n\n  // Add a dictionary to keep track of the registered async reducers\n  store.asyncReducers = {}\n\n  // Create an inject reducer function\n  // This function adds the async reducer, and creates a new combined reducer\n  store.injectReducer = (key, asyncReducer) => {\n    store.asyncReducers[key] = asyncReducer\n    store.replaceReducer(createReducer(store.asyncReducers))\n  }\n\n  // Return the modified store\n  return store\n}\n\nfunction createReducer(asyncReducers) {\n  return combineReducers({\n    ...staticReducers,\n    ...asyncReducers\n  })\n}\n")),(0,a.kt)("p",null,"Now, one just needs to call ",(0,a.kt)("inlineCode",{parentName:"p"},"store.injectReducer")," to add a new reducer to the store."),(0,a.kt)("h3",{id:"using-a-reducer-manager"},"Using a 'Reducer Manager'"),(0,a.kt)("p",null,"Another approach is to create a 'Reducer Manager' object, which keeps track of all the registered reducers and exposes a ",(0,a.kt)("inlineCode",{parentName:"p"},"reduce()")," function. Consider the following example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"export function createReducerManager(initialReducers) {\n  // Create an object which maps keys to reducers\n  const reducers = { ...initialReducers }\n\n  // Create the initial combinedReducer\n  let combinedReducer = combineReducers(reducers)\n\n  // An array which is used to delete state keys when reducers are removed\n  let keysToRemove = []\n\n  return {\n    getReducerMap: () => reducers,\n\n    // The root reducer function exposed by this object\n    // This will be passed to the store\n    reduce: (state, action) => {\n      // If any reducers have been removed, clean up their state first\n      if (keysToRemove.length > 0) {\n        state = { ...state }\n        for (let key of keysToRemove) {\n          delete state[key]\n        }\n        keysToRemove = []\n      }\n\n      // Delegate to the combined reducer\n      return combinedReducer(state, action)\n    },\n\n    // Adds a new reducer with the specified key\n    add: (key, reducer) => {\n      if (!key || reducers[key]) {\n        return\n      }\n\n      // Add the reducer to the reducer mapping\n      reducers[key] = reducer\n\n      // Generate a new combined reducer\n      combinedReducer = combineReducers(reducers)\n    },\n\n    // Removes a reducer with the specified key\n    remove: key => {\n      if (!key || !reducers[key]) {\n        return\n      }\n\n      // Remove it from the reducer mapping\n      delete reducers[key]\n\n      // Add the key to the list of keys to clean up\n      keysToRemove.push(key)\n\n      // Generate a new combined reducer\n      combinedReducer = combineReducers(reducers)\n    }\n  }\n}\n\nconst staticReducers = {\n  users: usersReducer,\n  posts: postsReducer\n}\n\nexport function configureStore(initialState) {\n  const reducerManager = createReducerManager(staticReducers)\n\n  // Create a store with the root reducer function being the one exposed by the manager.\n  const store = createStore(reducerManager.reduce, initialState)\n\n  // Optional: Put the reducer manager on the store so it is easily accessible\n  store.reducerManager = reducerManager\n}\n")),(0,a.kt)("p",null,"To add a new reducer, one can now call ",(0,a.kt)("inlineCode",{parentName:"p"},'store.reducerManager.add("asyncState", asyncReducer)'),"."),(0,a.kt)("p",null,"To remove a reducer, one can now call ",(0,a.kt)("inlineCode",{parentName:"p"},'store.reducerManager.remove("asyncState")')),(0,a.kt)("h2",{id:"libraries-and-frameworks"},"Libraries and Frameworks"),(0,a.kt)("p",null,"There are a few good libraries out there that can help you add the above functionality automatically:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/Microsoft/redux-dynamic-modules"},(0,a.kt)("inlineCode",{parentName:"a"},"redux-dynamic-modules")),":\nThis library introduces the concept of a 'Redux Module', which is a bundle of Redux artifacts (reducers, middleware) that should be dynamically loaded. It also exposes a React higher-order component to load 'modules' when areas of the application come online. Additionally, it has integrations with libraries like ",(0,a.kt)("inlineCode",{parentName:"li"},"redux-thunk")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"redux-saga")," which also help dynamically load their artifacts (thunks, sagas)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/markerikson/redux-ecosystem-links/blob/master/reducers.md#dynamic-reducer-injection"},"Redux Ecosystem Links: Reducers - Dynamic Reducer Injection"))))}u.isMDXComponent=!0}}]);